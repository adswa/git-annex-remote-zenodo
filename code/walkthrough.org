#+TITLE:       Walkthrough (complete tutorial)
#+AUTHOR:      Oumaima Hajji
#+STARTUP: overview indent inlineimages logdrawer
#+TAGS: R(R) Python(p) OrgMode(O) 

* Introduction.
In this file, we will be using the programs we have implemented to
initialize and manipulate a git-annex remote which is this case a
Zenodo special remote.

This tutorial is devided into a few steps in order to regroup the
tasks that belong together and execute them in a logical order with
explanations that go with them. So, in the first step, we will have to
prepare a directory where all the next tests will be held, before
starting on the more technical steps concerning the remote. 

* Initializing the remote.
1. First, we need to export the path to where the git-annex-remote-zenodo
function so as to be able to locate it when executing. Since that
program is in the same path as we are right now, we can just put the
current path .
#+BEGIN_SRC shell :session *shell* :results output :exports both
export PATH=$PATH:$(pwd)
#+END_SRC

#+RESULTS:
: !!: command not found

Let's check if the path has been successfully exported:
#+BEGIN_SRC shell :session *shell* :results output :exports both
echo $PATH
#+END_SRC

#+RESULTS:
: /home/nubudi/anaconda2/bin:/home/nubudi/anaconda2/condabin:/home/nubudi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/nubudi/Desktop/Internship/code

We also need to make the git-annex-remote-zenodo executable so as to
be able to execute it as a command. To do this, we can simply
change the permissions in the properties of the program (by checking
the box) or we can do it using the shell command line with ths
command (go to the path where the program is to execute it):

#+BEGIN_SRC shell :session *shell* :results output :exports both
chmod +x git-annex-remote-zenodo
#+END_SRC

#+RESULTS:

For this, We will need the sheebang line #!/usr/bin/env python3 to
execute this command which we added to the program.

2. Now, let's make the directory where we will be doing our tests.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~
mkdir test_remote
cd test_remote
#+END_SRC

#+RESULTS:

3. Then, we have to initialize the git and the git annex directory before
we move on to the next steps. 

#+BEGIN_SRC shell :session *shell* :results output :exports both 
git init
git annex init
#+END_SRC

#+RESULTS:
: Initialized empty Git repository in /home/nubudi/test_remote/.git/
: init  ok
: (recording state in git...)

4. Now, we can simply work with git annex like we would usually
   do. Since we have already initialized git and git annex in this
   repository, we now only need to initialize a Zenodo special remote
   using the command with added options (ex: url to specify if we want
   to use the sandbox or newversion if we want to initialize the
   remote as a new version of an already published remote).
   In this case, and since this is a test, we will be using the
   sandbox, and so we need to specify the option url=sandbox. We will
   be working with a brand new deposit and so we won't be using the
   newversion option for now. The rest of the options is self
   explanatory: key is the access token (since we will be using the
   sandbox, you need an access key created on
   https://sandbox.zenodo.org/account/settings/applications/)

#+begin_src shell :session *shell* :results output :exports both
git annex initremote test-zenodo type=external externaltype=zenodo key=K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG encryption=none url=sandbox
#+end_src

#+RESULTS:
: initremote test-zenodo finished the post operation. Here is the returned message :201
: 
: ok
: (recording state in git...)

* Preparing the files for the remote.
Now, and in order to manipulate a git-annex remote, we will need to
add some files to this directory. This could be done either manually
by choosing some local files and copying them here, or by creating new
random files as test subjects. This is what will be done in this
case.
First, we will be pulling words from a remote dictionary using the
requests library. Then, we will use the random.choices method to pick
random words from that list. We can then use these chosen words (after
turning the elements of the list into a string with the String
function join()) to write in new files we create.

Here is the python program that does this:

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/test_remote
#+END_SRC

#+RESULTS:

#+begin_src python :results output :exports both
import requests
import random
import os

# chnaging into the correct directory for the test
u = os.path.expanduser('~/test_remote')
os.chdir(u)

# fetching the words from the dictionary
words = "https://www.mit.edu/~ecprice/wordlist.10000"
response = requests.get(words)
# putting the words in a list
wordlist = response.content.splitlines()

# choosing random words from the list and writing into files
for i in range(5):
    chosenwords = random.choices(wordlist, k=random.randint(1,50))
    s = ' '.join(str(i) for i in chosenwords)
    f= open("test%s.txt" % str(i), "w")
    f.write(s)
    f.close()

#+end_src

#+RESULTS:

* Manipulating the files in the remote.
1. Now that we have finished with the initial preparations of the
   depository, we can start working with the remote. As a first step,
   we can annex the files we have just created.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/test_remote
git annex add . 
#+END_SRC

#+RESULTS:
: 
: add test0.txt ok
: add test1.txt ok
: add test2.txt ok
: add test3.txt ok
: add test4.txt ok
: (recording state in git...)

We can find all the files that have been added to the annex.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

As we can see, they are all seen as annexed and avaialble locally.
#+RESULTS:
#+begin_example
finished the get operation. Here is the returned message :200

here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X___ test1.txt
X___ test2.txt
X___ test3.txt
X___ test4.txt
#+end_example

2. Now, let's copy these files to the remote. We can either copy them
   all or choose the ones we are most interested in storing in the
   deposit. For this example, I've just chosen to copy three of the
   files we have created and leave the rest available only locally.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex copy test1.txt --to test-zenodo
git annex copy test2.txt --to test-zenodo
git annex copy test3.txt --to test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
copy test1.txt finished the get operation. Here is the returned message :200

check present
finished the get operation. Here is the returned message :200

(to test-zenodo...) 
finished the put operation. Here is the returned message :200

finished exporting the file... 

ok
(recording state in git...)
copy test2.txt finished the get operation. Here is the returned message :200

check present
finished the get operation. Here is the returned message :200

(to test-zenodo...) 
finished the put operation. Here is the returned message :200

finished exporting the file... 

ok
(recording state in git...)
copy test3.txt finished the get operation. Here is the returned message :200

check present
finished the get operation. Here is the returned message :200

(to test-zenodo...) 
finished the put operation. Here is the returned message :200

finished exporting the file... 

ok
(recording state in git...)
#+end_example

Now, let's check the files we have uploaded to see if they have been
successfully uploaded to the remote. We can either do this for each
file using the whereis command, or use the list command to show all
the annexed files and their positions.

Here is a first step with the whereis command for the file test1.txt:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex whereis test1.txt
#+END_SRC

We can see in the results that this file is now available in both the
remote and here locally.
#+RESULTS:
: whereis test1.txt finished the get operation. Here is the returned message :200
: 
: (2 copies) 
:   	bbbaa91d-63d7-4c64-8714-1a713a01ebb7 -- nubudi@ubunto:~/test_remote [here]
:    	e0ab0fb1-d056-4738-850d-73ded5c50a52 -- [test-zenodo]
: ok

And now, let's do the same using the second command and for all the
files:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

The same coud be said about the other two files that we have copied
into the remote.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X__X test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

3. Now, let's drop one of the files we have uploaded from the
   remote. This is done to see if the program we have implemented
   works and also to test the usefulness of git-annex remotes.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop test1.txt --from test-zenodo
#+END_SRC

#+RESULTS:
: drop test-zenodo test1.txt finished the get operation. Here is the returned message :200
: 
: remove
: finished the get operation. Here is the returned message :200
: 
: finished the delete operation. Here is the returned message :204
: 
: ok
: (recording state in git...)

Now, let's list the annexed files to see if the files test1.txt is
still available in the remote:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

As we can see, it's only available locally now.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X___ test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example


4. Now, we can try moving a file from a position to another. We can
   either move it from the remote to here or from the local position
   to the remote. When we move a file from a remote to another or locally it's as if we
   made two operations: copying it to X and dropping it from Y. So it's
   useful to do this when we already keep track of where all the copies
   of a file is and we just want to move it around without having to drop
   it everytime.

   It's better to check where a certain file is before we start moving
   it so as to have full knowledge of all the places it is. As we have
   tested in the step above, the file test1.txt is only available
   locally because we have dropped it from the remote.
   So now, we can try to move the file from here locally to the
   remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex move test1.txt --to test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
move test1.txt finished the get operation. Here is the returned message :200

check present
finished the get operation. Here is the returned message :200

(to test-zenodo...) 
finished the put operation. Here is the returned message :200

finished exporting the file... 

ok
(recording state in git...)
#+end_example

Once the operation is finished, we can check the whereabouts of this
file again:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list 
#+END_SRC

As we can see, it's no longer available locally but it's accessible in
the remote.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
___X test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

5. Now, let's try something new, this time having the file only
   available on the remote and trying to get it to here.

   To do this, we can first list all the files that are annexed and
   see where the file is kept now.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
___X test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

   We then can choose either a file that's not here but is on the
   remote or we can do this manually by dropping a file that is here
   from its local position and then getting it from the remote. But
   since file1.txt already answers this criteria, we can just try this
   operation on it straight-away.


#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop test2.txt
#+END_SRC

#+RESULTS:
: drop test2.txt finished the get operation. Here is the returned message :200
: 
: check present
: finished the get operation. Here is the returned message :200
: 
: Yes, this file exists in the remote: SHA256E-s437--78d7b5b8be5a96a92b84c5b9d78f39180ca9c5bef7228ffffc464698131059fe.txt
: ok
: (recording state in git...)

   
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex get test2.txt --from test-zenodo
#+END_SRC

#+RESULTS:
: get test2.txt (from test-zenodo...) 
: finished the get operation. Here is the returned message :200
: 
: finished the get operation. Here is the returned message :200
: 
: finished the get operation. Here is the returned message :200
: 
: (checksum...) ok
: (recording state in git...)

Now, let's check to see if git-annex succeeded in getting the file
from the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

As we can see from the results, the file test2.txt that wasn't
available locally just a few moments ago is now here and available for
our use.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
___X test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

> We can continue playing with files this way, annexing the ones we want
to store and copying/moving them from/to the remote. We can drop them either
locally if we no longer want them there, or drop them from the remote
as well.

* Disabling the remote.
Once we finish working with a certain remote, it's time to disable
it. To do this, we will be using a program that takes care of all the
steps that are necessary for a remote to be disabled. In our case,
this program first publishes the Zenodo deposit that has been created
when we initialized the remote. Then, it transforms all the annexed
files that have been published in the deposit into web remotes and
adds them in git-annex. Lastly, it deletes the remote locally.

To do so, we will only need the necessary information that will allow
us to acess the deposit (deposit id and the access token). We will
also use a file containing all the necessary metadata for publishing
so as to not have to give the information in the command line.

First, let's just create a simple json file (example: zenodo.json)
with these metadata.
