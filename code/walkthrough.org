#+TITLE:       Walkthrough (complete tutorial)
#+AUTHOR:      Oumaima Hajji
#+STARTUP: overview indent inlineimages logdrawer
#+TAGS: R(R) Python(p) OrgMode(O) 

* Introduction.
In this file, we will be using the programs we have implemented to
initialize and manipulate a git-annex remote which is this case a
Zenodo special remote.

This tutorial is devided into a few steps in order to regroup the
tasks that belong together and execute them in a logical order with
explanations that go with them. So, in the first step, we will have to
prepare a directory where all the next tests will be held, before
starting on the more technical steps concerning the remote. 

* Initializing the remote.
1. First, we need to export the path to where the git-annex-remote-zenodo
function so as to be able to locate it when executing. Since that
program is in the same path as we are right now, we can just put the
current path .
#+BEGIN_SRC shell :session *shell* :results output :exports both
export PATH=$PATH:$(pwd)
#+END_SRC

#+RESULTS:


Let's check if the path has been successfully exported:
#+BEGIN_SRC shell :session *shell* :results output :exports both
echo $PATH
#+END_SRC

#+RESULTS:
: /home/nubudi/anaconda2/bin:/home/nubudi/anaconda2/condabin:/home/nubudi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/nubudi/Desktop/Internship/code

We also need to make the git-annex-remote-zenodo executable so as to
be able to execute it as a command. To do this, we can simply
change the permissions in the properties of the program (by checking
the box) or we can do it using the shell command line with ths
command (go to the path where the program is to execute it):

#+BEGIN_SRC shell :session *shell* :results output :exports both
chmod +x git-annex-remote-zenodo
#+END_SRC

#+RESULTS:

For this, We will need the sheebang line #!/usr/bin/env python3 to
execute this command which we added to the program.

2. Now, let's make the directory where we will be doing our tests.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~
mkdir test_remote
cd test_remote
#+END_SRC

#+RESULTS:

3. Then, we have to initialize the git and the git annex directory before
we move on to the next steps. 

#+BEGIN_SRC shell :session *shell* :results output :exports both 
git init
git annex init
#+END_SRC

#+RESULTS:
: Initialized empty Git repository in /home/nubudi/test_remote/.git/
: init  ok
: (recording state in git...)

4. Now, we can simply work with git annex like we would usually
   do. Since we have already initialized git and git annex in this
   repository, we now only need to initialize a Zenodo special remote
   using the command with added options (ex: url to specify if we want
   to use the sandbox or newversion if we want to initialize the
   remote as a new version of an already published remote).
   In this case, and since this is a test, we will be using the
   sandbox, and so we need to specify the option url=sandbox. We will
   be working with a brand new deposit and so we won't be using the
   newversion option for now. The rest of the options is self
   explanatory: key is the access token (since we will be using the
   sandbox, you need an access key created on
   https://sandbox.zenodo.org/account/settings/applications/)

#+begin_src shell :session *shell* :results output :exports both
git annex initremote test-zenodo type=external externaltype=zenodo key=K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG encryption=none url=sandbox
#+end_src

#+RESULTS:
: initremote test-zenodo finished the post operation. Here is the returned message :201
: 
: ok
: (recording state in git...)

* Preparing the files for the remote.
Now, and in order to manipulate a git-annex remote, we will need to
add some files to this directory. This could be done either manually
by choosing some local files and copying them here, or by creating new
random files as test subjects. This is what will be done in this
case.
First, we will be pulling words from a remote dictionary using the
requests library. Then, we will use the random.choices method to pick
random words from that list. We can then use these chosen words (after
turning the elements of the list into a string with the String
function join()) to write in new files we create.

Here is the python program that does this:

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/test_remote
#+END_SRC

#+RESULTS:

#+begin_src python :results output :exports both
import requests
import random
import os

# chnaging into the correct directory for the test
u = os.path.expanduser('~/test_remote')
os.chdir(u)

# fetching the words from the dictionary
words = "https://www.mit.edu/~ecprice/wordlist.10000"
response = requests.get(words)
# putting the words in a list
wordlist = response.content.splitlines()

# choosing random words from the list and writing into files
for i in range(5):
    chosenwords = random.choices(wordlist, k=random.randint(1,50))
    s = ' '.join(str(i) for i in chosenwords)
    f= open("test%s.txt" % str(i), "w")
    f.write(s)
    f.close()

#+end_src

#+RESULTS:

* Manipulating the files in the remote.
1. Now that we have finished with the initial preparations of the
   depository, we can start working with the remote. As a first step,
   we can annex the files we have just created.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/test_remote
git annex add . 
#+END_SRC

#+RESULTS:
: 
: add test0.txt ok
: add test1.txt ok
: add test2.txt ok
: add test3.txt ok
: add test4.txt ok
: (recording state in git...)

We can find all the files that have been added to the annex.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

As we can see, they are all seen as annexed and avaialble locally.
#+RESULTS:
#+begin_example
finished the get operation. Here is the returned message :200

here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X___ test1.txt
X___ test2.txt
X___ test3.txt
X___ test4.txt
#+end_example

2. Now, let's copy these files to the remote. We can either copy them
   all or choose the ones we are most interested in storing in the
   deposit. For this example, I've just chosen to copy three of the
   files we have created and leave the rest available only locally.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex copy test1.txt --to test-zenodo
git annex copy test2.txt --to test-zenodo
git annex copy test3.txt --to test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
copy test1.txt finished the get operation. Here is the returned message :200

finished the get operation. Here is the returned message :200

(to test-zenodo...) 
finished the put operation. Here is the returned message :200

finished exporting the file... 



ok
(recording state in git...)
copy test2.txt finished the get operation. Here is the returned message :200

finished the get operation. Here is the returned message :200

(to test-zenodo...) 
finished the put operation. Here is the returned message :200



finished exporting the file... 

ok
(recording state in git...)
copy test3.txt finished the get operation. Here is the returned message :200

finished the get operation. Here is the returned message :200

(to test-zenodo...) 
finished the put operation. Here is the returned message :200



finished exporting the file... 

ok
(recording state in git...)
#+end_example

Now, let's check the files we have uploaded to see if they have been
successfully uploaded to the remote. We can either do this for each
file using the whereis command, or use the list command to show all
the annexed files and their positions.

Here is a first step with the whereis command for the file test1.txt:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex whereis test1.txt
#+END_SRC

We can see in the results that this file is now available in both the
remote and here locally.
#+RESULTS:
: whereis test1.txt finished the get operation. Here is the returned message :200
: 
: (2 copies) 
:   	66b28db8-283d-4358-b306-7e966b9864e2 -- nubudi@ubunto:~/test_remote [here]
:    	e52a5f22-9783-40fb-a1a7-9a0a25e2ef08 -- [test-zenodo]
: ok


And now, let's do the same using the second command and for all the
files:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

The same coud be said about the other two files that we have copied
into the remote.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X__X test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

3. Now, let's drop one of the files we have uploaded from the
   remote. This is done to see if the program we have implemented
   works and also to test the usefulness of git-annex remotes.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop test1.txt --from test-zenodo
#+END_SRC

#+RESULTS:
: drop test-zenodo test1.txt finished the get operation. Here is the returned message :200
: 
: finished the get operation. Here is the returned message :200
: 
: finished the delete operation. Here is the returned message :204
: 
: ok
: (recording state in git...)

Now, let's list the annexed files to see if the files test1.txt is
still available in the remote:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

As we can see, it's only available locally now.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X___ test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

5. Now, let's try something new, this time having the file only
   available on the remote and trying to get it to here.

   To do this, we can first list all the files that are annexed and
   see where the file is kept now.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X___ test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

   We then can choose either a file that's not here but is on the
   remote or we can do this manually by dropping a file that is here
   from its local position and then getting it from the remote. But
   since file1.txt already answers this criteria, we can just try this
   operation on it straight-away.


#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop test3.txt
#+END_SRC

#+RESULTS:
: drop test3.txt finished the get operation. Here is the returned message :200
: 
: finished the get operation. Here is the returned message :200
: 
: Yes, this file exists in the remote: SHA256E-s384--4e2ab8d53db6354bb9dd3e019eb47e0578ea60f4e898bc2c64d5814ab6f33fda.txt
: ok
: (recording state in git...)


We can now check to see if it has been successfully dropped locally
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

Which is the case since the file test2.txt is no longer in here but
it's still available in the test-zenodo remote.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X___ test1.txt
X__X test2.txt
___X test3.txt
X___ test4.txt
#+end_example


#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex get test3.txt --from test-zenodo
#+END_SRC

#+RESULTS:
: get test3.txt (from test-zenodo...) 
: finished the get operation. Here is the returned message :200
: 
: finished the get operation. Here is the returned message :200
: 
: finished the get operation. Here is the returned message :200
: 
: 

(checksum...) ok
: (recording state in git...)

Now, let's check to see if git-annex succeeded in getting the file
from the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

As we can see from the results, the file test3.txt that wasn't
available locally just a few moments ago is now here and available for
our use.
#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
X___ test0.txt
X___ test1.txt
X__X test2.txt
X__X test3.txt
X___ test4.txt
#+end_example

> We can continue playing with files this way, annexing the ones we want
to store and copying/moving them from/to the remote. We can drop them either
locally if we no longer want them there, or drop them from the remote
as well.

* Disabling the remote.
Once we finish working with a certain remote, it's time to disable
it. To do this, we will be using a program that takes care of all the
steps that are necessary for a remote to be disabled
(git-annex-disableremote.py).
In our case, this program first publishes the Zenodo deposit that has
been created when we initialized the remote. Then, it transforms all
the annexed files that have been published in the deposit into web
remotes and adds them in git-annex. Lastly, it deletes the remote locally.

To do so, we will only need the necessary information that will allow
us to acess the deposit (deposit id and the access token). We will
also use a file containing all the necessary metadata for publishing
so as to not have to give the information in the command line.

First, let's just create a simple json file (example: zenodo.json)
with example metadata to allow us to publish. For this, we can just
copy the example that was given in the zenodo tutorial
(https://developers.zenodo.org/?python#quickstart-upload) or we can
create our own with information that concerns us.

I've added a file in the directory that contains the code source files
for the internship and so it could be used to pass this test. You
could also change things in the file according to the type of content
you want to publish (this all could be found in the tutorial in the
same url given earlier).

Let's write the file using a python program which creates a dictionary
and fills it in with all the metadata that's needed before dumping the
content of this dictionary in a zenodo.json file.
#+begin_src python :results output :exports both
import os
import json

# filling dico with information
dico= {}
metadata = {}
dico['title'] = "Test upload"
dico['upload_type'] = "poster"
dico['description'] = "This is a test to publish a deposit"
dico['creators'] = [{'name': 'Doe, John', 'affiliation': 'researcher'}]
dico['access_right'] = "closed"
# creating the the other dictionary metadata that has dico as a value for the key metadata
metadata['metadata'] = dico

outputpath = os.getcwd() + "/zenodo.json"
print(outputpath)
# opening the file and writing into it.
f = open(outputpath, "w+")
json.dump(metadata, f)
f.close()
#+end_src

Now, we can execute the program giving it the id of the deposit, the
access key, and the path to the zenodo.json file.
- First, we will need the id of the deposit and this could be known
  easily by checking the uploads on the zenodo website. Depending on
  whether or nor the sandbox is used, we can get the id on the upload
  window. But here, we can write a program that automatically looks
  for the id for us without us having to do it on the browser. So,
  this is what we will do in the following function.
  #+begin_src python :results output :exports both
import subprocess
import os
import shlex

# getting the current directory where this file is (and the python script as well)
cwd = os.getcwd()
# changing the directory to that of the test
u = os.path.expanduser('~/test_remote')
os.chdir(u)
remote_path = os.getcwd()
# reading the file from the other branch without checking into it
output = subprocess.getoutput("git show git-annex:./remote.log")
s = shlex.split(output, comments=True, posix=False)
for elm in s:
    # looking through the elemnts for the index of the id
    if elm.startswith("deposit_id"):
        id = elm.split("=")[-1]

# now, let's execute the command to disable the remote
progpath = cwd + "/git-annex-disableremote.py"
jsonfilepath = cwd + "/zenodo.json"

os.system("python3 "+ progpath + " -i " + id + " -k K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG -f " + jsonfilepath + " -u sandbox")
#+end_src

  #+RESULTS:
  : addurl https://sandbox.zenodo.org/api/files/5fba796e-e301-4e23-9b5f-37ca92a3c0d0/SHA256E-s155--d87820702c4e436875270b5ad392d7a54c3fca4a06b15db98f64d7054e6a86e6.txt?access_token=K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG ok
  : (recording state in git...)
  : addurl https://sandbox.zenodo.org/api/files/5fba796e-e301-4e23-9b5f-37ca92a3c0d0/SHA256E-s384--4e2ab8d53db6354bb9dd3e019eb47e0578ea60f4e898bc2c64d5814ab6f33fda.txt?access_token=K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG ok
  : (recording state in git...)
  : 32768

  Now, we can finally take a look at the results after the operation
  of disabling the remote. As we can see, there were two major changes
  in the result of the command list:
  - Firstly, the two files that were on the Zenodo remote (test2.txt and
    test3.txt) are now available on the web, which means that they
    have been successfully turned into web remotes.
    This step was taken care of by the function transformtoweb.
  - Secondly, the Zenodo remote (test-zenodo) no longer appears in the list of the
    remotes where the files are kept. This shows that the remote has
    been successfully removed.
    This was done by the command 'git remote remove' in the
    disableremotelocally method which looks in the file remote.log for
    the remote that we want to remove and then removes it from git.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
: here
: |web
: ||bittorrent
: |||
: X__ test0.txt
: X__ test1.txt
: XX_ test2.txt
: XX_ test3.txt
: X__ test4.txt

 We can also check the list of the remotes that are kept in git and we
 can see that we get nothing in result, which would have been
 different if we still have remotes in this directory.

 #+BEGIN_SRC shell :session *shell* :results output :exports both
git remote
#+END_SRC

#+RESULTS:
 


* Initializing a new version of a deposit.




