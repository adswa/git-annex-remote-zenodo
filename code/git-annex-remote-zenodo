#!/usr/bin/env python


from annexremote import Master
from annexremote import ExportRemote
from annexremote import RemoteError, ProtocolError

import sys, os, errno

import requests

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'

class ZenodoRemote(ExportRemote):

    def __init__(self, *args):
        self.deposit = None
        self.deposit_id = None
        self.key = ''

    # method to handle all the basic queries
    def query(self, query_method, url, headers=None, data=None, stream = None):
        # id = key (!= KEY or access token to the API): to be stored in the remote. 
        # In most cases, this is going to be the remote file name. It should be at 
        # least be unambigiously derived from it.

        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        params = {'access_token': self.key}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            # this is for when we want to retrieve and download the file
            if stream == True:
                request = requests.get(url, params = params, stream = True)
            else:
                request = requests.get(url, params = params)
        elif query_method == 'post':
            request = requests.post(url, params=params, json={}, headers=headers)
        elif query_method == 'put':
            request = requests.put(url, params=params, json={}, data=data)
        else:
            request = requests.delete(url, params)
            
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + "operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request


    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        import requests
        # need to get the key by using the getconfig method
        self.key = self.annex.getconfig('key')
        # the key is passed as an argument when using the commant initremote (ex: key='')
        # if it's not been added as an argument, we raise an 
        if self.annex.getconfig('key') is None:
            raise RemoteError("You need to add the access token (key = TOKEN)")

        # now, we need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        if r.status_code > 204:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a post query to the API')
        
        # setting the id for this deposit
        self.deposit = r
        self.deposit_id = r.json()['id']
        self.deposit_bucket = r.json()['links']['bucket']
        


    def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use
        import requests
        # let's try to connect to the API, if the status code is not 200: there is an error 
        self.key = self.annex.getconfig('key')
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')
                

    def transfer_store(self, key, filename):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        try:
            # fetching the url of the bucket
            URL_BUCKET = self.deposit_bucket

            # and then we upload it

            #filename = 'notes.pdf'
            #path = '/home/nubudi/Downloads/notes.pdf'

            # extracting the filename and the path from filename
            # the argument filename of the function contains the full path to the path.
            # we  can get the name of the file by using the function rsplit to split 
            # the string at the specified separator '/' and we can get the filename by 
            # getting the lest element of the file.
            list = filename.rsplit("/")
            file = list[-1]
            path = filename

            # The target URL is a combination of the bucket link with the desired filename
            # seperated by a slash.
            with open(path, "rb") as fp:
                r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
            
            if r.status_code < 400:
                print("finished exporting the file... \n")
            else:
                raise RemoteError ('error while exporting the file... \n')

        except Exception as error:
            raise RemoteError(error)


    def transfer_retrieve(self, key, filename):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
        import json
        # getting the information on the files that are in the deposit
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)

        # going through the list of the files in this deposit
        for i in range(len(r.json())):
            # checking if the file exists by comparing the key/filename
            # sending a get request to check information on the file
            if r.json()[i]['filename'] == key:
                # we can retrieve a single deposition file with: 
                # url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files/' + str(file_id)
                # getting the id of the file that we want to download
                file_id =  r.json()[i]['id']
                # getting the download link of the file
                url = r.json()[i]['links']['download']
                r = self('get', url, stream = True)        
                r.raise_for_status()
                # storing the file in the path given in filename
                # this is done by reading the content of the file and writing it in the new file
                # if the files are very large, we can make the chunk size bigger 
                with open(filename, "wb") as f:
                    for chunk in r.iter_content(chunk_size=120): 
                        f.write(chunk)
                # once we finish writing into the file we can close it
                f.close()

        if r.status_code > 204:
            print("error while fetching the file from the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')
        

    def checkpresent(self, key):
        # return True if the key is present in the remote
        # return False if the key is not present
        # raise RemoteError if the presence of the key couldn't be determined, eg. in case of connection error

        try:
            url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
            r = self.query('get', url)
            # going through the list of the files in this deposit
            for i in range(len(r.json())):
                if r.json()[i]['filename'] == key:
                    print('Yes, this file exists in the remote: ' + key )
                    return True
            return False 
            
        except Exception as error:
            raise RemoteError(error)


    def remove(self, key):
        # remove the key from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        # checking if the key exists in the remote deposit
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        file_id = None
        for i in range(len(r.json())):
            if r.json()[i]['filename'] == key:
                file_id = r.json()[i]['id']

        # if the key is non existing, we shouldn't raise an exception        
        if file_id is None:
            return
        
        # Delete an existing deposition file resource. Note, only deposition 
        # files for unpublished depositions may be deleted.

        # first, we update the url so as to use it to delete the file
        url = url + '/' + str(file_id)
        # we then make the query to delete the file
        r = self.query('delete', url)

        # raising RemoteError if there is a problem with the removal of the file
        if r.status_code > 204:
            print("error while deleting the file from the remote" + str(r.status_code))
            raise RemoteError('could not send a delete query to the API')
        

    def transferexport_store(self, key, local_file, remote_file):
        # store the file located at `local_file` to `remote_file` on the remote
        # raise RemoteError if the file couldn't be stored

        return self.transfer_store(key, local_file)
        # and set the key later on using a put command to be able to retrieve files
        # or: self.transfer_store(remote_file, local_file) which means setting 
        # the name of the file in the remote as the key.
        
        
    def transferexport_retrieve(self, key, local_file, remote_file):
        # get the file located at `remote_file` from the remote and store it to `local_file`
        # raise RemoteError if the file couldn't be retrieved

        return self.transfer_retrieve(key, local_file)
        # same idea

    def checkpresentexport(self, key, remote_file):
        # return True if the file `remote_file` is present in the remote
        # return False if not
        # raise RemoteError if the presence of the file couldn't be determined, eg. in case of connection error
        
        return self.checkpresent(key)
        # same idea

    def removeexport(self, key, remote_file):
        # remove the file in `remote_file` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        return self.remove(key)
        # same idea

    def removeexportdirectory(self, remote_directory):
        # remove the directory `remote_directory` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing directory isn't considered an error

        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        file_id = None
        # manipulating each of the files in this deposit
        for i in range(len(r.json())):
            file_id = r.json()[i]['id']
            if file_id is not None:     
                # Delete an existing deposition file resource. Note, only deposition 
                # files for unpublished depositions may be deleted.
                # first, we update the url so as to use it to delete the file
                url = url + '/' + str(file_id)
                # we then make the query to delete the file
                r = self.query('delete', url)
                # for each of the files
                # raising RemoteError if there is a problem with the removal of the file
                if r.status_code > 204: 
                    print("error while deleting the " + str(i) + " file from the remote" + str(r.status_code))
                    raise RemoteError('could not send a delete query to the API')
        

    def renameexport(self, key, filename, new_filename):
        # move the remote file in `name` to `new_name`
        # raise RemoteError if it couldn't be moved

        # when it's not published we can simply edit the name with the edit function
        print("not implemented")

    # added methods

    # function to call whenever we can to choose an upload type:
    def setting_uploadtype(self):
        # the possible types of the uploads
        uploadtypes = ['publication', 'poster', 'presentation', 'dataset', 'image', 
                        'video', 'software', 'lesson', 'physicalobject', 'other']

        # in the case: upload_type == 'publication'
        publicationtypes = ['annotationcollection', 'book', 'section', 'conferencepaper', 'datamanagementplan', 
                            'article', 'patent', 'prepint', 'deliverable', 'milestone', 'proposal', 'report', 
                            'softwaredocumentation', 'taxonomictreatment', 'technicalnote', 'thesis', 'workingpaper', 'other']
        # in the case: upload_type == 'image'
        imagetypes = ['figure', 'plot', 'drawing', 'diagram', 'photo', 'other']

        # asking for the initial type of the upload:
        print("What is the type of the upload? Please choose one of these options (ex: 5) \n")
        print("0 - publication \n")
        print("1 - poster \n")
        print("2 - presentation \n")
        print("3 - dataset \n")
        print("4 - image \n")
        print("5 - video \n")        
        print("6 - software \n")
        print("7 - lesson \n")
        print("8 - physical object \n")
        print("9 - other \n")
        n = int(input('Enter the correspoding number: '))
        upload_type = uploadtypes[n]


        # taking care of the information concerning the publication type:
        if upload_type == 'publication':
            print('Here are the possible types of publication. Please choose one of them (ex: 5) \n')
            print("0 - annotation collection \n")
            print("1 - book \n")
            print("2 - section \n")
            print("3 - data management plan \n")
            print("4 - article \n")
            print("5 - patent \n")
            print("6 - preprint \n")
            print("7 - deliverable \n")
            print("8 - milestone \n")
            print("9 - proposal \n")
            print("10 - software documentation \n")
            print("11 - taxonomic treatment \n")
            print("12 - technical note \n")
            print("13 - thesis \n")
            print("14 - working paper \n")
            print("15 - other \n")
            n = int(input('Enter the correspoding number: '))
            upload_type = publicationtypes[n]

        elif upload_type == 'image':
            print('Here are the possible types of images. Please choose one of them (ex: 5) \n')
            print("0 - figure \n")
            print("1 - plot \n")
            print("2 - drawing \n")
            print("3 - diagram \n")
            print("4 - photo \n")
            print("5 - other \n")
            n = int(input('Enter the correspoding number: '))
            upload_type = imagetypes[n]
        
        return upload_type 

    # function to call to set the creators of the upload. 
    # This function is called whenever the user wants to publish an upload.
    def setting_creators(self):
        creators = []
        c = {}
        nbcreators = int(input("Enter the number of the creators of this upload. \n"))
        for i in range(nbcreators):
            print("For the " + str(i) + " creator: \n")
            family_name = input('Enter the Family name (Required): \n')
            given_name = input('Enter the Given name (Required): \n')
            affiliation = input('Enter the affiliation of the creator or press enter to pass (Optional): \n')
            orcid = input('Enter the orcid of the creator or press enter to pass (Optional): \n')
            gnd = input('Enter the gnd of the creator or press enter to pass (Optional): \n')
            c['name'] = "%s, %s" % (family_name, given_name)
            if affiliation != '':
                c['affiliation'] = affiliation
            if orcid != '':
                c['orcid'] = orcid
            if gnd != '':
                c['gnd'] = gnd
            creators.append(c)

        return creators

    # function to call to set the access right to the publication. The user 
    # chooses which type of access to give and takes care of any additional 
    # information that depends on the chosen access. 
    # This function is called whenever the user wants to publish an upload.
    def setting_accessright (self):
        
        # initializing the list of options
        accessrights = ['open', 'embargoed', 'restricted', 'closed']
        licenses = ['Creative Commons Attribution 4.0 International', 'Creative Commons Attribution 1.0 Generic', 
                    'Creative Commons Attribution 2.0 Generic', 'Creative Commons Attribution 3.0 Unported']
        
        # choosing the access right 
        print("What is the access right of the upload? Please choose one of these options (ex: 2) \n")
        print("0 - open \n")
        print("1 - embargoed \n")
        print("2 - restricted \n")
        print("3 - closed \n")        
        n = int(input('Enter the correspoding number: '))
        access_right = accessrights[n]        

        # taking care of the extra information concerning all the possible access rights
        
        if access_right == 'embargoed':
            # need to specify embargo_date
            print('Specify the Embargo date. The format is: YYYY-MM-DD. \n')
            embargo_date = input()

        if access_right == 'embargoed' or access_right == 'open':
            # need to specify the license
            print('Specify the license. Choose one of these options: \n')
            print("0 - Creative Commons Attribution 4.0 International \n")
            print("1 - Creative Commons Attribution 1.0 Generic \n")
            print("2 - Creative Commons Attribution 2.0 Generic \n")
            print("3 - Creative Commons Attribution 3.0 Unported \n")               
            n = int(input('Enter the correspoding number: ')) 
            license = licenses[n]

        if access_right == 'restricted':
            # need to specify access_conditions
            print('Specify the conditions under which you grant users access to the files in your upload. \n')
            access_conditions = input()

    # this is the function that will be used to publish the deposit
    def publish(self):
        import json
        # initializing the required metadata
        
        # setting the type of the upload using the choosetype function
        upload_type = self.setting_uploadtype() 
        
        # setting the title of the upload
        title = input('Enter the title of the upload: ')
        
        # setting the description of the upload
        description = input('Enter a basic description of the upload')
        
        # setting the access right of the upload
        access_right = self.setting_accessright()
        
        # getting information about the creators of the publication
        creators = self.setting_creators()
  

    # adding metadata to the deposit
        data = {
            'metadata': {
                'title': title,
                'upload_type': upload_type,
                'description': description,
                'creators': creators,
                'access_right': access_right
            }
        }

        # updating the deposit with the needed metadata
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/%s' % self.deposit_id
        r = self.query('put', url, data=json.dumps(data))

        # publishing
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % self.deposit_id
        r = self.query('post', url)




def main():
    # Redirect output to stderr to avoid messing up the protocol
    output = sys.stdout
    sys.stdout = sys.stderr
    
    master = Master(output)
    remote = ZenodoRemote(master)
    master.LinkRemote(remote)
    master.Listen()

if __name__ == "__main__":
    main()        


