#!/usr/bin/env python


from annexremote import Master
from annexremote import ExportRemote
from annexremote import RemoteError, ProtocolError

import sys, os, errno

import requests

URL_API = 'https://zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'

class ZenodoRemote(ExportRemote):

    # method to handle the basic queries
    def query(self, query_method, url, headers=None, data=None):

        # query_method: depending on the case, could be requests.put, requests.post, or requests.get.
        # url: could be that of the API, or that of the bucket where we want to deposit a file.
        # headers: ex: {"Content-Type": "application/json"}
        # data: information we want to deposit. we can import the json package and use it to convert it into json.

        import json
        import requests

        if headers is None:
            headers = {}

        # formatting the data
        if data is not None:
            data = json.dumps(data)

        params = {'access_token': KEY}    

        # depending on the query, some of the arguments might be null
        request = query_method(url, params=params, headers=headers, data=data)
        print(request.status_code)

        # maybe pass this as an argument as well?
        #print("do you want to see the json return of the query? \n")
        #n = input()
        #if n == "yes":
        #	print(request.json())
        return request

    # methods to implement
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        #self.key = input("inter the token \n")
	    KEY = 'WgYPkomVp1HpJniDmwS2ylFBhwsNpntxFzKqo02HGij94nVFlO0tAefboqtn'


    def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use
        import requests
        # let's try to connect to the API, if the status code is not 200: there is an error 
        r = self.query(requests.get, URL_API)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))


    def transfer_store(self, key, filename):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        import requests

        # uploading the file:

        # we first need to create an empty upload
        r = self.query(requests.post, URL_API)

        # now, we upload the file (cf the tips in the tutorial)
        # to do so, we will fetch the bucket_url which will be the folder containing the files
        URL_BUCKET = r.json()["links"]["bucket"]

        # and then we upload it
        filename = input("inter the name of the file you want to send (ex: toto.zip) \n")
        path = input("inter the path to the file (ex: /path/to/toto.zip) \n")

        # The target URL is a combination of the bucket link with the desired filename
        # seperated by a slash.
        with open(path, "rb") as fp:
            r = self.query(requests.put, "%s/%s" % (URL_BUCKET, filename), data=fp)
        
        if r.status_code < 400:
            print("finished exporting the file... \n")
        else:
            raise RemoteError ('error')

        # Publishing the file 


    def transfer_retrieve(self, key, filename):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
        print("a")

    def checkpresent(self, key):
        # return True if the key is present in the remote
        # return False if the key is not present
        # raise RemoteError if the presence of the key couldn't be determined, eg. in case of connection error
        print("not implemented")

    def remove(self, key):
        # remove the key from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error
        print("not implemented")

    # Additional methods:

    def transferexport_store(self, key, local_file, remote_file):
        # store the file located at `local_file` to `remote_file` on the remote
        # raise RemoteError if the file couldn't be stored
        print("not implemented")
        
    def transferexport_retrieve(self, key, local_file, remote_file):
        # get the file located at `remote_file` from the remote and store it to `local_file`
        # raise RemoteError if the file couldn't be retrieved
        print("not implemented")

    def checkpresentexport(self, key, remote_file):
        # return True if the file `remote_file` is present in the remote
        # return False if not
        # raise RemoteError if the presence of the file couldn't be determined, eg. in case of connection error
        print("not implemented")

    def removeexport(self, key, remote_file):
        # remove the file in `remote_file` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error
        print("not implemented")

    def removeexportdirectory(self, remote_directory):
        # remove the directory `remote_directory` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing directory isn't considered an error
        print("not implemented")

    def renameexport(self, key, filename, new_filename):
        # move the remote file in `name` to `new_name`
        # raise RemoteError if it couldn't be moved
        print("not implemented")


def main():
    # Redirect output to stderr to avoid messing up the protocol
    output = sys.stdout
    sys.stdout = sys.stderr
    
    master = Master(output)
    remote = ZenodoRemote(master)
    master.LinkRemote(remote)
    master.Listen()

if __name__ == "__main__":
    main()        


