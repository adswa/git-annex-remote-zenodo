#!/usr/bin/env python


from annexremote import Master
from annexremote import ExportRemote
from annexremote import RemoteError, ProtocolError

import sys, os, errno

import requests

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'

class ZenodoRemote(ExportRemote):

    def __init__(self, *args):
        self.deposit = None
        self.deposit_id = None
        self.key = ''

    # method to handle all the basic queries
    def query(self, query_method, url, id=None, headers=None, data=None):
        # id = key (!= KEY or access token to the API): to be stored in the remote. 
        # In most cases, this is going to be the remote file name. It should be at 
        # least be unambigiously derived from it.

        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        # for put / post   
        if id is not None:    
            params = {'access_token': self.key, 'identifier' : id}   
        # for get (when we don't have an identifier for the file, ie: when we still haven't uploaded it)
        else:
            params = {'access_token': self.key}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            request = requests.get(url, params = params)
        else:
            if query_method == 'post': 
                request = requests.post(url, params=params, json={}, headers=headers)
            else:
                request = requests.put(url, params=params, json={}, data=data)
                
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + "operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request


    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        import requests
        # need to get the key by using the getconfig method
        self.key = self.annex.getconfig('key')
        # the key is passed as an argument when using the commant initremote (ex: key='')
        # if it's not been added as an argument, we raise an 
        if self.annex.getconfig('key') is None:
            raise RemoteError("You need to add the access token (key = TOKEN)")

        # now, we need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        if r.status_code > 204:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a post query to the API')
        
        # setting the id for this deposit
        self.deposit = r
        self.deposit_id = r.json()['id']
        self.deposit_bucket = r.json()['links']['bucket']
        


    def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use
        import requests
        # let's try to connect to the API, if the status code is not 200: there is an error 
        self.key = self.annex.getconfig('key')
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')
                

    def transfer_store(self, key, filename):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        # uploading the file:
        r = self.deposit
        # now, we upload the file (cf the tips in the tutorial)
        # to do so, we will fetch the bucket_url which will be the folder containing the files
        URL_BUCKET = r.json()["links"]["bucket"]

        # todo: extract the path and the filename from arg 'filename'

        # and then we upload it
        filename = 'notes.pdf'
        path = '/home/nubudi/Downloads/notes.pdf'
        
        # The target URL is a combination of the bucket link with the desired filename
        # seperated by a slash.
        with open(path, "rb") as fp:
            r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
        
        if r.status_code < 400:
            print("finished exporting the file... \n")
        else:
            raise RemoteError ('error while exporting the file... \n')

        # todo: publishing the file 
        # simply by using a post query


    def transfer_retrieve(self, key, filename):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved

        # get request to: https://sandbox.zenodo.org/api/deposit/depositions
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)

        if r.status_code > 204:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')
        

    def checkpresent(self, key):
        # return True if the key is present in the remote
        # return False if the key is not present
        # raise RemoteError if the presence of the key couldn't be determined, eg. in case of connection error

        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        for i in range(len(r.json())):
            if r.json()[i]['filename'] == key:
                print('yes, this file exists in the remote: ' + key )
                return True
        return False 


    def remove(self, key):
        # remove the key from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        print("not implemented")

    def transferexport_store(self, key, local_file, remote_file):
        # store the file located at `local_file` to `remote_file` on the remote
        # raise RemoteError if the file couldn't be stored

        return self.transfer_store(key, local_file)
        # and set the key later on using a put command to be able to retrieve files
        # or: self.transfer_store(remote_file, local_file) which means setting 
        # the name of the file in the remote as the key.
        
        
    def transferexport_retrieve(self, key, local_file, remote_file):
        # get the file located at `remote_file` from the remote and store it to `local_file`
        # raise RemoteError if the file couldn't be retrieved

        return self.transfer_retrieve(key, local_file)
        # same idea

    def checkpresentexport(self, key, remote_file):
        # return True if the file `remote_file` is present in the remote
        # return False if not
        # raise RemoteError if the presence of the file couldn't be determined, eg. in case of connection error
        
        return self.checkpresentexport(key)
        # same idea

    def removeexport(self, key, remote_file):
        # remove the file in `remote_file` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        return self.remove(key)
        # same idea

    def removeexportdirectory(self, remote_directory):
        # remove the directory `remote_directory` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing directory isn't considered an error

        print("not implemented")

    def renameexport(self, key, filename, new_filename):
        # move the remote file in `name` to `new_name`
        # raise RemoteError if it couldn't be moved

        print("not implemented")


def main():
    # Redirect output to stderr to avoid messing up the protocol
    output = sys.stdout
    sys.stdout = sys.stderr
    
    master = Master(output)
    remote = ZenodoRemote(master)
    master.LinkRemote(remote)
    master.Listen()

if __name__ == "__main__":
    main()        


