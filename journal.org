
#+TITLE:       lab book
#+AUTHOR:      Oumaima Hajji
#+STARTUP: overview indent inlineimages logdrawer
#+TAGS: R(R) Python(p) OrgMode(O) 


* Monday 31/05.

** first step: get.
  We start off by writing a small function to test the get query on
  the API. To do this, it is imperative to have the token (can
  be easily created on sandbox.zenodo) and have the access to do all
  queries. 

  #+begin_src python :results output :exports both
import requests
import json
def api():
    # get 
    ACCESS_TOKEN = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'
    r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions', params={'access_token': ACCESS_TOKEN})
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))

api()
#+end_src

  #+RESULTS:
  #+begin_example
  200
  [
      {
	  "conceptrecid": "844528",
	  "created": "2021-06-01T08:33:34.266269",
	  "id": 844529,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844529/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844529/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844529/files",
	      "html": "https://sandbox.zenodo.org/deposit/844529",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844529/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844529"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844529",
		  "recid": 844529
	      }
	  },
	  "modified": "2021-06-01T08:33:34.266278",
	  "owner": 72937,
	  "record_id": 844529,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844522",
	  "created": "2021-06-01T08:33:24.802909",
	  "id": 844523,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844523/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844523/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844523/files",
	      "html": "https://sandbox.zenodo.org/deposit/844523",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844523/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844523"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844523",
		  "recid": 844523
	      }
	  },
	  "modified": "2021-06-01T08:33:24.802918",
	  "owner": 72937,
	  "record_id": 844523,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844458",
	  "created": "2021-06-01T07:39:16.531542",
	  "id": 844459,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844459/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844459/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844459/files",
	      "html": "https://sandbox.zenodo.org/deposit/844459",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844459/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844459"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844459",
		  "recid": 844459
	      }
	  },
	  "modified": "2021-06-01T07:39:16.531556",
	  "owner": 72937,
	  "record_id": 844459,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844456",
	  "created": "2021-06-01T07:39:12.578429",
	  "id": 844457,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844457/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844457/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844457/files",
	      "html": "https://sandbox.zenodo.org/deposit/844457",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844457/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844457"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844457",
		  "recid": 844457
	      }
	  },
	  "modified": "2021-06-01T07:39:12.578441",
	  "owner": 72937,
	  "record_id": 844457,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844454",
	  "created": "2021-06-01T07:39:08.535444",
	  "id": 844455,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844455/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844455/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844455/files",
	      "html": "https://sandbox.zenodo.org/deposit/844455",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844455/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844455"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844455",
		  "recid": 844455
	      }
	  },
	  "modified": "2021-06-01T07:39:08.535460",
	  "owner": 72937,
	  "record_id": 844455,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844203",
	  "created": "2021-06-01T00:54:44.267674",
	  "id": 844204,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844204/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844204/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844204/files",
	      "html": "https://sandbox.zenodo.org/deposit/844204",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844204/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844204"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844204",
		  "recid": 844204
	      }
	  },
	  "modified": "2021-06-01T00:54:44.267682",
	  "owner": 72937,
	  "record_id": 844204,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844199",
	  "created": "2021-06-01T00:53:24.332368",
	  "id": 844200,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844200/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844200/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844200/files",
	      "html": "https://sandbox.zenodo.org/deposit/844200",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844200/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844200"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844200",
		  "recid": 844200
	      }
	  },
	  "modified": "2021-06-01T00:53:24.332376",
	  "owner": 72937,
	  "record_id": 844200,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844197",
	  "created": "2021-06-01T00:53:23.090962",
	  "id": 844198,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844198/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844198/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844198/files",
	      "html": "https://sandbox.zenodo.org/deposit/844198",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844198/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844198"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844198",
		  "recid": 844198
	      }
	  },
	  "modified": "2021-06-01T00:53:23.090971",
	  "owner": 72937,
	  "record_id": 844198,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844195",
	  "created": "2021-06-01T00:53:21.840632",
	  "id": 844196,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844196/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844196/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844196/files",
	      "html": "https://sandbox.zenodo.org/deposit/844196",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844196/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844196"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844196",
		  "recid": 844196
	      }
	  },
	  "modified": "2021-06-01T00:53:21.840641",
	  "owner": 72937,
	  "record_id": 844196,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844193",
	  "created": "2021-06-01T00:53:20.538909",
	  "id": 844194,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844194/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844194/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844194/files",
	      "html": "https://sandbox.zenodo.org/deposit/844194",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844194/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844194"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844194",
		  "recid": 844194
	      }
	  },
	  "modified": "2021-06-01T00:53:20.538926",
	  "owner": 72937,
	  "record_id": 844194,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      }
  ]
  #+end_example

  
** second step: post.
   Adding the argument headers to specify the content type because we
   want a json app. We also still need the access token because we
   can't make any query to the API without it.
   When we don't use the argument json={} we get an error and we can't
   use the response message to move on.

  #+begin_src python :results output :exports both
def apipost():
    import requests
    headers = {"Content-Type": "application/json"}
    params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, headers=headers)
    print(r.status_code)

apipost()

  #+end_src
  
  #+RESULTS:
  : 400

  Now that we've added the argument json={}, we get the message 201,
  meaning that the request succeeded.
  
  #+begin_src python :results output :exports both
def apipost():
    import json
    import requests
    headers = {"Content-Type": "application/json"}
    params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', json={}, params=params, headers=headers)
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))

apipost()

  #+end_src

  #+RESULTS:
  #+begin_example
  201
  {
      "conceptrecid": "844554",
      "created": "2021-06-01T08:40:17.198489+00:00",
      "files": [],
      "id": 844555,
      "links": {
	  "bucket": "https://sandbox.zenodo.org/api/files/c8b78c5d-39ed-42c2-bbf6-62d03c7ed06f",
	  "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844555/actions/discard",
	  "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844555/actions/edit",
	  "files": "https://sandbox.zenodo.org/api/deposit/depositions/844555/files",
	  "html": "https://sandbox.zenodo.org/deposit/844555",
	  "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/844555",
	  "latest_draft_html": "https://sandbox.zenodo.org/deposit/844555",
	  "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844555/actions/publish",
	  "self": "https://sandbox.zenodo.org/api/deposit/depositions/844555"
      },
      "metadata": {
	  "prereserve_doi": {
	      "doi": "10.5072/zenodo.844555",
	      "recid": 844555
	  }
      },
      "modified": "2021-06-01T08:40:17.198497+00:00",
      "owner": 72937,
      "record_id": 844555,
      "state": "unsubmitted",
      "submitted": false,
      "title": ""
  }
  #+end_example

  
   Headers are not necessary here since "requests" automatically adds
   "Content-Type: application/json", because we're using the "json="
   keyword argument headers=headers.
   A test without the headers argument:
     
  #+begin_src python :results output :exports both
def apipost():
    import requests
    headers = {"Content-Type": "application/json"}
    params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', json={}, params=params)
    print(r.status_code)

apipost()

  #+end_src

  #+RESULTS:
  : 201

  
** step three: merging the two and posting on the API
   now we just write a bigger program where we do the necessary steps
   to communicate with the API in chronological order. First, we send
   a get request to check the access. Then, we create an empty
   depository and we upload a file.
   
  #+begin_src python :results output :exports both

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'
import os
import json
import requests

# method to handle all the basic queries
def query(query_method, url, headers=None, data=None):
    
    # making sure that the headers are specified before sending the request
    if headers is None:
        headers = {"Content-Type": "application/json"}
        
    # we use the same access key for all the queries.    
    params = {'access_token': KEY}

    # depending on the query, some of the arguments might be null
    if query_method == 'get':
        request = requests.get(url, params = params)
    else:
        if query_method == 'post': 
            request = requests.post(url, params=params, json={}, headers=headers)
        else:
            request = requests.put(url, params=params, json={}, data=data)
            
    # informing the user of the currint state of the operation        
    print("finished the " + query_method + "operation. Here is the returned message \n")
    print(request.status_code)

    #returning the resulting request for later uses
    return request


# this is the main method to call to transfer data
def transfer_store():
    # first step: get
    r = query('get', URL_SANDBOX)
    
    #creating an empty upload with post
    r = query('post', URL_SANDBOX)
    print(r.json())
    
    # now, we upload the file (cf the tips in the tutorial)
    # to do so, we will fetch the bucket_url which will be the folder containing the files
    URL_BUCKET = r.json()['links']['bucket']
        
    ID = r.json()['id']
    print(ID)

    # and then we upload it
    filename = 'AirPollutionInGrenoble.pdf'
    path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'
    #filename = input("inter the name of the file you want to send (ex: toto.zip) \n")
    #path = input("inter the path to the file (ex: /path/to/toto.zip) \n")

    # The target URL is a combination of the bucket link with the desired filename
    # seperated by a slash.
    with open(path, "rb") as fp:
        r = query('put', "%s/%s" % (URL_BUCKET, filename), data=fp)
        
    if r.status_code < 400:
        print("finished exporting the file... \n")

    
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % ID, params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    if r.status_code < 400:
        print("finished publishing the file... \n")


transfer_store()

  #+end_src

  #+RESULTS:
  #+begin_example
  finished the getoperation. Here is the returned message 

  200
  finished the postoperation. Here is the returned message 

  201
  {'conceptrecid': '844830', 'created': '2021-06-01T11:49:14.047438+00:00', 'files': [], 'id': 844831, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/21ea259d-d1ed-419f-92d0-f10585bda674', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/files', 'html': 'https://sandbox.zenodo.org/deposit/844831', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/844831', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/844831', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844831'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.844831', 'recid': 844831}}, 'modified': '2021-06-01T11:49:14.047460+00:00', 'owner': 72937, 'record_id': 844831, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  844831
  finished the putoperation. Here is the returned message 

  200
  finished exporting the file... 

  401
  {
      "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
      "status": 401
  }
  #+end_example

  - new version with added functionalities

  #+begin_src python :results output :exports both

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'
import os
import json
import requests

# method to handle all the basic queries
def query(query_method, url, key_id=None,  headers=None, data=None):
    
    # making sure that the headers are specified before sending the request
    if headers is None:
        headers = {"Content-Type": "application/json"}
        
    # we use the same access key for all the queries.    
    params = {'access_token': KEY}

    # depending on the query, some of the arguments might be null
    if query_method == 'get':
        request = requests.get(url, params = params)
    else:
        if query_method == 'post': 
            request = requests.post(url, params=params, json={}, headers=headers)
        else:
            request = requests.put(url, params=params, json={}, data=data)
            
    # informing the user of the currint state of the operation        
    print("finished the " + query_method + "operation. Here is the returned message \n")
    print(request.status_code)

    #returning the resulting request for later uses
    return request


# this is the main method to call to transfer data
def transfer_store (key):
    # first step: get
    r = query('get', URL_SANDBOX)
    
    #creating an empty upload with post
    r = query('post', URL_SANDBOX)
    print(r.json())
    
    # now, we upload the file (cf the tips in the tutorial)
    # to do so, we will fetch the bucket_url which will be the folder containing the files
    URL_BUCKET = r.json()['links']['bucket']

    # and then we upload it
    filename = 'AirPollutionInGrenoble.pdf'
    path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'
    #filename = input("inter the name of the file you want to send (ex: toto.zip) \n")
    #path = input("inter the path to the file (ex: /path/to/toto.zip) \n")

    # The target URL is a combination of the bucket link with the desired filename
    # seperated by a slash.
    with open(path, "rb") as fp:
        r = query('put', "%s/%s" % (URL_BUCKET, filename), data=fp)

    print(r.json())
    """
    # now, we set the key in the remote by sending a put query
    deposition_id = r.json()['id']
    data = {'key_id': key}
    r = query('put', 'https://zenodo.org/api/deposit/depositions/%s' % deposition_id, data=json.dumps(data))
    """
    if r.status_code < 400:
        print("finished exporting the file... \n")


def transfer_retrieve(key):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved

        # get request to: https://sandbox.zenodo.org/api/deposit/depositions 
    uuuurl = 'https://sandbox.zenodo.org/api/deposit/depositions/844128/files'
    r = query('get', uuuurl)
    print(r.json())

#transfer_store('testet')
transfer_retrieve('testet')


  #+end_src

  #+RESULTS:
  : finished the getoperation. Here is the returned message 
  : 
  : 200
  : [{'checksum': '96379d6f2dfdbdd68ee0fa48a31ee07c', 'filename': 'AirPollutionInGrenoble.pdf', 'filesize': 1107977, 'id': 'd4ecf116-ff2d-4fcb-8c1e-c31065f73b31', 'links': {'download': 'https://sandbox.zenodo.org/api/files/28c34351-9840-4b62-b297-699ec90bd027/AirPollutionInGrenoble.pdf', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844088/files/d4ecf116-ff2d-4fcb-8c1e-c31065f73b31'}}]

  #+begin_src python :results output :exports both
import requests

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


class ZenodoRemote():

    def __init__(self):
        self.deposit = None
        self.deposit_id = None

    # method to handle all the basic queries
    def query(self, query_method: str, url, id=None, headers=None, data=None):
        # id = key (!= KEY or access token to the API): to be stored in the remote. 
        # In most cases, this is going to be the remote file name. It should be at 
        # least be unambigiously derived from it.
        import requests

        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        # for put / post   
        if id is not None:    
            params = {'access_token': KEY, 'identifier' : id}   
        # for get (when we don't have an identifier for the file, ie: when we still haven't uploaded it)
        else:
            params = {'access_token': KEY}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            request = requests.get(url, json={}, params = params)
        else:
            if query_method == 'post': 
                request = requests.post(url, params=params, json={}, headers=headers)
            else:
                request = requests.put(url, params=params, json={}, data=data)
                
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + "operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request


    # methods to implement
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        #self.key = input("inter the token \n")
	    KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


    def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use

        # let's try to connect to the API, if the status code is not 200: there is an error 
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
        
        # we first need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        print(r.json())

        self.deposit = r
        self.deposit_id = r.json()['id']
        # finished preparing the remote


    def transfer_store(self, key):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        # uploading the file:
        r = self.deposit
        # now, we upload the file (cf the tips in the tutorial)
        # to do so, we will fetch the bucket_url which will be the folder containing the files
        URL_BUCKET = r.json()["links"]["bucket"]

        # todo: extract the path and the filename from arg 'filename'

        # and then we upload it
        filename = 'notes.pdf'
        path = '/home/nubudi/Downloads/notes.pdf'
        
        # The target URL is a combination of the bucket link with the desired filename
        # seperated by a slash.
        with open(path, "rb") as fp:
            r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
        
        if r.status_code < 400:
            print("finished exporting the file... \n")
        
        # todo: publishing the file 
        # simply by using a post query

    def transfer_retrieve(self, key):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
	    
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        print(r.json())
        

    # Redirect output to stderr to avoid messing up the protocol
remote = ZenodoRemote()
remote.initremote()
remote.prepare()
remote.transfer_store('notes.pdf')
remote.transfer_retrieve('notes.pdf') 
  #+end_src

  #+RESULTS:
  #+begin_example
  finished the getoperation. Here is the returned message 

  200
  finished the postoperation. Here is the returned message 

  201
  {'conceptrecid': '844143', 'created': '2021-06-01T00:13:57.858160+00:00', 'files': [], 'id': 844144, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/4e680567-c908-4a94-88b0-af5ab11551f6', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/files', 'html': 'https://sandbox.zenodo.org/deposit/844144', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/844144', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/844144', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844144'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.844144', 'recid': 844144}}, 'modified': '2021-06-01T00:13:57.858173+00:00', 'owner': 72937, 'record_id': 844144, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  finished the putoperation. Here is the returned message 

  200
  finished exporting the file... 

  finished the getoperation. Here is the returned message 

  200
  [{'checksum': '2d2d364fe89375260446330175bd832f', 'filename': 'notes.pdf', 'filesize': 180064, 'id': 'a05fa9ca-0087-4c3f-9915-4e657e39312e', 'links': {'download': 'https://sandbox.zenodo.org/api/files/4e680567-c908-4a94-88b0-af5ab11551f6/notes.pdf', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/files/a05fa9ca-0087-4c3f-9915-4e657e39312e'}}]
  #+end_example

  
** fct
  #+begin_src python :results output :exports both
import requests

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


class ZenodoRemote():

    def __init__(self):
        self.deposit = None
        self.deposit_id = None

    # method to handle all the basic queries
    def query(self, query_method: str, url, id=None, headers=None, data=None):
        # id = key (!= KEY or access token to the API): to be stored in the remote. 
        # In most cases, this is going to be the remote file name. It should be at 
        # least be unambigiously derived from it.
        import requests

        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        # for put / post   
        if id is not None:    
            params = {'access_token': KEY, 'identifier' : id}   
        # for get (when we don't have an identifier for the file, ie: when we still haven't uploaded it)
        else:
            params = {'access_token': KEY}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            request = requests.get(url, json={}, params = params)
        else:
            if query_method == 'post': 
                request = requests.post(url, params=params, json={}, headers=headers)
            else:
                request = requests.put(url, params=params, json={}, data=data)
                
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + "operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request


    # methods to implement
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        #self.key = input("inter the token \n")
	    KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


    def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use

        # let's try to connect to the API, if the status code is not 200: there is an error 
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
        
        # we first need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        print(r.json())

        self.deposit = r
        self.deposit_id = r.json()['id']
        # finished preparing the remote


    def transfer_store(self, key):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        # uploading the file:
        r = self.deposit
        # now, we upload the file (cf the tips in the tutorial)
        # to do so, we will fetch the bucket_url which will be the folder containing the files
        URL_BUCKET = r.json()["links"]["bucket"]

        # todo: extract the path and the filename from arg 'filename'

        # and then we upload it
        filename = 'notes.pdf'
        path = '/home/nubudi/Downloads/notes.pdf'
        
        # The target URL is a combination of the bucket link with the desired filename
        # seperated by a slash.
        with open(path, "rb") as fp:
            r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
        
        with open('/home/nubudi/Downloads/AirPollutionInGrenoble.pdf', "rb") as fp:
            r = self.query('put', "%s/%s" % (URL_BUCKET, 'AirPollutionInGrenoble.pdf'), key, data=fp)
        

        if r.status_code < 400:
            print("finished exporting the file... \n")
        
        # todo: publishing the file 
        # simply by using a post query

    def transfer_retrieve(self, key):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
	    
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        for i in range(len(r.json())):
            if r.json()[i]['filename'] == key:
                print('yes, this file exists in the remote: ' + key )
                return True
        return False 

    # Redirect output to stderr to avoid messing up the protocol
remote = ZenodoRemote()
remote.initremote()
remote.prepare()
remote.transfer_store('notes.pdf')
remote.transfer_retrieve('notes.pdf')
    

  #+end_src

  #+RESULTS:
  #+begin_example
  finished the getoperation. Here is the returned message 

  200
  finished the postoperation. Here is the returned message 

  201
  {'conceptrecid': '844652', 'created': '2021-06-01T09:52:04.046805+00:00', 'files': [], 'id': 844653, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/fb4504f0-cd8b-4eed-ba47-1de6197ee38d', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/files', 'html': 'https://sandbox.zenodo.org/deposit/844653', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/844653', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/844653', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844653'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.844653', 'recid': 844653}}, 'modified': '2021-06-01T09:52:04.046814+00:00', 'owner': 72937, 'record_id': 844653, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  finished the putoperation. Here is the returned message 

  200
  finished the putoperation. Here is the returned message 

  200
  finished exporting the file... 

  finished the getoperation. Here is the returned message 

  200
  yes, this file exists in the remote: notes.pdf
  #+end_example




  #+begin_src shell :session *shell* :results output :exports both 
cd code
chmod +x git-annex-remote-zenodo
  #+end_src

  #+RESULTS:


    #+begin_src shell :session *shell* :results output :exports both 
git init
git annex init
export PATH=$PATH:/path_to_file
git annex initremote choose_name externaltype=zenodo encryption=none type=external
  #+end_src

  #+RESULTS:
  : Initialized empty Git repository in /home/nubudi/Desktop/Internship/code/.git/
  : init  ok
  : (recording state in git...)




  # New version

  - publishing and creating a new version.
    
    #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
id_last_version =  '844653'
ACCESS_TOKEN = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/844653', params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})

print(r.status_code)

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/publish', params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

    #+end_src

    #+RESULTS:
    : 200
    : 401
    : {
    :     "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
    :     "status": 401
    : }

  

  

* Tuesday 01/06.
** new test with a new access token.
   #+begin_src python :results output :exports both
import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)
print(r.json())

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

print(r.json())

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:
   : 201
   : {'conceptrecid': '845104', 'created': '2021-06-01T14:08:14.923411+00:00', 'files': [], 'id': 845105, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/files', 'html': 'https://sandbox.zenodo.org/deposit/845105', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/845105', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/845105', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/845105'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.845105', 'recid': 845105}}, 'modified': '2021-06-01T14:08:14.923420+00:00', 'owner': 72937, 'record_id': 845105, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
   : {'mimetype': 'application/pdf', 'updated': '2021-06-01T14:08:15.247795+00:00', 'links': {'self': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70/AirPollutionInGrenoble.pdf', 'version': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70/AirPollutionInGrenoble.pdf?versionId=0df5f345-2925-46ad-b420-28b996700d82', 'uploads': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70/AirPollutionInGrenoble.pdf?uploads'}, 'is_head': True, 'created': '2021-06-01T14:08:15.243098+00:00', 'checksum': 'md5:96379d6f2dfdbdd68ee0fa48a31ee07c', 'version_id': '0df5f345-2925-46ad-b420-28b996700d82', 'delete_marker': False, 'key': 'AirPollutionInGrenoble.pdf', 'size': 1107977}
   : 401
   : {
   :     "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
   :     "status": 401
   : }



  look into this: test if we can make a new version of a deposit that is
  not published.

  - first try without having already published the deposit that we
    will be creating a new version of.

  #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

concept_id = r.json()["conceptrecid"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})
print(r.status_code)

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id , params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})
print(r.status_code)


id = 845033
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/newversion?access_token=kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY' % id, json={} , headers={"Content-Type": "application/json"})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

  #+end_src

  #+RESULTS:
  #+begin_example
  201
  200
  401
  {
      "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
      "status": 401
  }
  200
  201
  {
      "conceptdoi": "10.5072/zenodo.845032",
      "conceptrecid": "845032",
      "created": "2021-06-01T13:29:15.931719+00:00",
      "doi": "10.5072/zenodo.845033",
      "doi_url": "https://doi.org/10.5072/zenodo.845033",
      "files": [
	  {
	      "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	      "filename": "AirPollutionInGrenoble.pdf",
	      "filesize": 1107977,
	      "id": "509b0d36-afaf-4e83-87a2-e75af144ef4d",
	      "links": {
		  "download": "https://sandbox.zenodo.org/api/files/a7c73360-8ccc-4d3b-b38e-39c03025e043/AirPollutionInGrenoble.pdf",
		  "self": "https://sandbox.zenodo.org/api/deposit/depositions/845033/files/509b0d36-afaf-4e83-87a2-e75af144ef4d"
	      }
	  }
      ],
      "id": 845033,
      "links": {
	  "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845033.svg",
	  "bucket": "https://sandbox.zenodo.org/api/files/a7c73360-8ccc-4d3b-b38e-39c03025e043",
	  "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845032.svg",
	  "conceptdoi": "https://doi.org/10.5072/zenodo.845032",
	  "doi": "https://doi.org/10.5072/zenodo.845033",
	  "latest": "https://sandbox.zenodo.org/api/records/845033",
	  "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/845066",
	  "latest_draft_html": "https://sandbox.zenodo.org/deposit/845066",
	  "latest_html": "https://sandbox.zenodo.org/record/845033",
	  "record": "https://sandbox.zenodo.org/api/records/845033",
	  "record_html": "https://sandbox.zenodo.org/record/845033"
      },
      "metadata": {
	  "access_right": "open",
	  "communities": [
	      {
		  "identifier": "zenodo"
	      }
	  ],
	  "creators": [
	      {
		  "name": "Oumaima HAJJI",
		  "orcid": "0000-0001-6353-0584"
	      }
	  ],
	  "description": "<p>test</p>",
	  "doi": "10.5072/zenodo.845033",
	  "license": "CC-BY-4.0",
	  "prereserve_doi": {
	      "doi": "10.5072/zenodo.845033",
	      "recid": 845033
	  },
	  "publication_date": "2021-06-01",
	  "publication_type": "article",
	  "title": "test",
	  "upload_type": "publication"
      },
      "modified": "2021-06-01T13:47:18.904756+00:00",
      "owner": 72937,
      "record_id": 845033,
      "state": "done",
      "submitted": true,
      "title": "test"
  }
  #+end_example


this is a test using a deposit that has been published privately

  #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

concept_id = r.json()["conceptrecid"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})
print(r.status_code)

id = 845065
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/newversion?access_token=kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY' % id, json={} , headers={"Content-Type": "application/json"})
print(r.status_code)
print(json.dumps(r.json(), indent=4))
  #+end_src

  #+RESULTS:
  #+begin_example
  201
  200
  201
  {
      "conceptdoi": "10.5072/zenodo.845064",
      "conceptrecid": "845064",
      "created": "2021-06-01T13:50:47.257899+00:00",
      "doi": "10.5072/zenodo.845065",
      "doi_url": "https://doi.org/10.5072/zenodo.845065",
      "files": [
	  {
	      "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	      "filename": "AirPollutionInGrenoble.pdf",
	      "filesize": 1107977,
	      "id": "a20de20a-2e91-4117-82d2-f220b6332129",
	      "links": {
		  "download": "https://sandbox.zenodo.org/api/files/89883821-8f6c-4047-a2ce-0c5ab10a8bfc/AirPollutionInGrenoble.pdf",
		  "self": "https://sandbox.zenodo.org/api/deposit/depositions/845065/files/a20de20a-2e91-4117-82d2-f220b6332129"
	      }
	  }
      ],
      "id": 845065,
      "links": {
	  "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845065.svg",
	  "bucket": "https://sandbox.zenodo.org/api/files/89883821-8f6c-4047-a2ce-0c5ab10a8bfc",
	  "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845064.svg",
	  "conceptdoi": "https://doi.org/10.5072/zenodo.845064",
	  "doi": "https://doi.org/10.5072/zenodo.845065",
	  "latest": "https://sandbox.zenodo.org/api/records/845065",
	  "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/845081",
	  "latest_draft_html": "https://sandbox.zenodo.org/deposit/845081",
	  "latest_html": "https://sandbox.zenodo.org/record/845065",
	  "record": "https://sandbox.zenodo.org/api/records/845065",
	  "record_html": "https://sandbox.zenodo.org/record/845065"
      },
      "metadata": {
	  "access_right": "closed",
	  "communities": [
	      {
		  "identifier": "zenodo"
	      }
	  ],
	  "creators": [
	      {
		  "name": "Oumaima Hajji",
		  "orcid": "0000-0001-6353-0584"
	      }
	  ],
	  "description": "<p>this is a test</p>",
	  "doi": "10.5072/zenodo.845065",
	  "prereserve_doi": {
	      "doi": "10.5072/zenodo.845065",
	      "recid": 845065
	  },
	  "publication_date": "2021-06-01",
	  "publication_type": "article",
	  "title": "test_closed_version",
	  "upload_type": "publication"
      },
      "modified": "2021-06-01T14:06:00.869938+00:00",
      "owner": 72937,
      "record_id": 845065,
      "state": "done",
      "submitted": true,
      "title": "test_closed_version"
  }
  #+end_example



** test: creating a deposit and putting files inside and then deleting
  the deposit and trying to access the files directly with an url


  #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)
print(r.json())

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

filename = 'notes.pdf'
path = '/home/nubudi/Downloads/notes.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(bucket_id) + '/files'
r = requests.get(url, params=params)

print(json.dumps(r.json(), indent=4))

  #+end_src

  #+RESULTS:
  #+begin_example
  201
  {'conceptrecid': '846316', 'created': '2021-06-02T13:00:02.044350+00:00', 'files': [], 'id': 846317, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/2197cc94-bb26-4958-8bee-5d3111346d8a', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/files', 'html': 'https://sandbox.zenodo.org/deposit/846317', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/846317', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/846317', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/846317'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.846317', 'recid': 846317}}, 'modified': '2021-06-02T13:00:02.044360+00:00', 'owner': 75563, 'record_id': 846317, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  [
      {
	  "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	  "filename": "AirPollutionInGrenoble.pdf",
	  "filesize": 1107977,
	  "id": "7c75fc07-a11b-432e-b8a1-2c7ebd96c060",
	  "links": {
	      "download": "https://sandbox.zenodo.org/api/files/2197cc94-bb26-4958-8bee-5d3111346d8a/AirPollutionInGrenoble.pdf",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/846317/files/7c75fc07-a11b-432e-b8a1-2c7ebd96c060"
	  }
      },
      {
	  "checksum": "2d2d364fe89375260446330175bd832f",
	  "filename": "notes.pdf",
	  "filesize": 180064,
	  "id": "01b77826-1ecb-478f-9853-bddc98a3cb3a",
	  "links": {
	      "download": "https://sandbox.zenodo.org/api/files/2197cc94-bb26-4958-8bee-5d3111346d8a/notes.pdf",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/846317/files/01b77826-1ecb-478f-9853-bddc98a3cb3a"
	  }
      }
  ]
  #+end_example


 before deleting the deposit, we can use the links 'self' and
 'download' to access the files. We then delete the deposit. This
 could be done easily via the user interface (the url is in this case
 https://sandbox.zenodo.org/deposit/845189, 845189 could be exchanged
 with the id of any deposit that we have created)
 Now, we only have to retry to access the files through the url given
 in the response message when we uploaded them in the deposit.

 #+begin_src python :results output :exports both
import requests
import json

print("trying to access the files with the download link \n")
r = requests.get("https://sandbox.zenodo.org/api/files/679deb7b-69cf-4499-bc6c-dc6c2e285678/notes.pdf", params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})
print(json.dumps(r.json(), indent=4))


print("trying to access the files with the self link")
r = requests.get("https://sandbox.zenodo.org/api/deposit/depositions/845189/files/017b9d94-8fed-4655-a11e-74b020e19a61", params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})
print(json.dumps(r.json(), indent=4))

#+end_src

#+RESULTS:
#+begin_example
trying to access the files with the download link 

{
    "message": "Bucket does not exist.",
    "status": 404
}
trying to access the files with the self link
{
    "status": 410,
    "message": "PID has been deleted."
}
#+end_example
 

As we can see in the response to the get query we sent, the files can
no longer be accessed via the urls.


** retrying to publish by adding some metadata before senfing the request

   #+begin_src python :results output :exports both
import requests
import json

ACCESS_TOKEN = '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'
r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions', params={'access_token': ACCESS_TOKEN})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

headers = {"Content-Type": "application/json"}
params = {'access_token': '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'}
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:

   
   #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'}

bucket_id = 845033

data = {
     'metadata': {
         'title': 'My first upload',
         'upload_type': 'poster',
         'description': 'This is my first upload',
         'creators': [{'name': 'Doe, John',
                       'affiliation': 'Zenodo'}]
     }
}

r = requests.put('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id, params=params, data=json.dumps(data), headers=headers, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params={'access_token': '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'}, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src


* Wednesday 02/06.

** publishing through the api.

    retrying to publish by adding some metadata before senfing the request

    - first: creating the deposit
   #+begin_src python :results output :exports both
import requests
import json

ACCESS_TOKEN = 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'
headers = {"Content-Type": "application/json"}
params = {'access_token': ACCESS_TOKEN}

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions', params=params)
print(r.status_code)
print(json.dumps(r.json(), indent=4))


r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers= headers)
print(r.json()["id"])
print(r.json()["links"]["bucket"])

print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:
   #+begin_example
   200
   []
   846331
   https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca
   201
   {
       "conceptrecid": "846330",
       "created": "2021-06-02T13:12:08.831740+00:00",
       "files": [],
       "id": 846331,
       "links": {
	   "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
	   "discard": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/discard",
	   "edit": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/edit",
	   "files": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files",
	   "html": "https://sandbox.zenodo.org/deposit/846331",
	   "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/846331",
	   "latest_draft_html": "https://sandbox.zenodo.org/deposit/846331",
	   "publish": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/publish",
	   "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331"
       },
       "metadata": {
	   "prereserve_doi": {
	       "doi": "10.5072/zenodo.846331",
	       "recid": 846331
	   }
       },
       "modified": "2021-06-02T13:12:08.831748+00:00",
       "owner": 75563,
       "record_id": 846331,
       "state": "unsubmitted",
       "submitted": false,
       "title": ""
   }
   #+end_example

     
   #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}

bucket_id = 846331  # we get this by choosing the id of one of the deposits we created

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id, params=params)
print(r.status_code)

# getting the url of the bucket using the id that we have
# to do this, we go through the list of the deposits that we have created and compare the id
"""
found = False
for i in range(2):
    if r.json()[i]["id"] == bucket_id:
        bucket_url =  r.json()[i]["links"]["bucket"]
        found = True
if found == False:
    print("oups, couldn't find the bucket url using this id")

print(bucket_url)
"""

# getting the url
bucket_url = r.json()["links"]["bucket"]

# uploading a file to the deposit
filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

# adding metadata to the deposit
data = {
     'metadata': {
         'title': 'Air pollution in Grenoble',
         'upload_type': 'poster',
         'description': 'first upload',
         'creators': [{'name': 'H, O',
                       'affiliation': 'Zenodo'}]
     }
}

r = requests.put('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id, params=params, data=json.dumps(data), headers=headers, json={})
print(r.status_code)

# publishing
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params=params, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:
   #+begin_example
   200
   200
   202
   {
       "conceptdoi": "10.5072/zenodo.846330",
       "conceptrecid": "846330",
       "created": "2021-06-02T13:12:08.831740+00:00",
       "doi": "10.5072/zenodo.846331",
       "doi_url": "https://doi.org/10.5072/zenodo.846331",
       "files": [
	   {
	       "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	       "filename": "AirPollutionInGrenoble.pdf",
	       "filesize": 1107977,
	       "id": "8b14ada3-07a2-4da4-a0af-6c18ce58ced4",
	       "links": {
		   "download": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca/AirPollutionInGrenoble.pdf",
		   "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files/8b14ada3-07a2-4da4-a0af-6c18ce58ced4"
	       }
	   }
       ],
       "id": 846331,
       "links": {
	   "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846331.svg",
	   "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
	   "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846330.svg",
	   "conceptdoi": "https://doi.org/10.5072/zenodo.846330",
	   "doi": "https://doi.org/10.5072/zenodo.846331",
	   "latest": "https://sandbox.zenodo.org/api/records/846331",
	   "latest_html": "https://sandbox.zenodo.org/record/846331",
	   "record": "https://sandbox.zenodo.org/api/records/846331",
	   "record_html": "https://sandbox.zenodo.org/record/846331"
       },
       "metadata": {
	   "access_right": "open",
	   "communities": [
	       {
		   "identifier": "zenodo"
	       }
	   ],
	   "creators": [
	       {
		   "affiliation": "Zenodo",
		   "name": "H, O"
	       }
	   ],
	   "description": "first upload",
	   "doi": "10.5072/zenodo.846331",
	   "license": "CC-BY-4.0",
	   "prereserve_doi": {
	       "doi": "10.5072/zenodo.846331",
	       "recid": 846331
	   },
	   "publication_date": "2021-06-02",
	   "title": "Air pollution in Grenoble",
	   "upload_type": "poster"
       },
       "modified": "2021-06-02T13:18:25.798500+00:00",
       "owner": 75563,
       "record_id": 846331,
       "state": "done",
       "submitted": true,
       "title": "Air pollution in Grenoble"
   }
   #+end_example


* Thursday 03/06.
  We will be using the Python library that already implements the
  external special remote protocol in order to create the new remote
  for Zenodo.
  Link: https://github.com/Lykos153/AnnexRemote

  The blueprint of the class is given with a few methods to
  implement. 

** Step 0: init.
   Initiating the instances of this class by defining the main
   attributes that are needed for the remote to function. This is
   where we define the key that is used to do all the basic API
   queries and where we initiate the id of the deposit that will be
   created once the remote is initiated with initremote.  

      #+begin_src python :results output :exports both
    def __init__(self, *args):
        self.deposit = None
        self.deposit_id = None
        self.deposit_bucket = None
        self.key = ''
      #+end_src

   
** Step 1: query.
   This is the method that we will be using to handle the basic
   queries to the API.
   
     #+begin_src python :results output :exports both
    def query(self, query_method, url, id=None, headers=None, data=None):
        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        # for put / post   
        if id is not None:    
            params = {'access_token': self.key, 'identifier' : id}   
        # for get (when we don't have an identifier for the file, ie: when we still haven't uploaded it)
        else:
            params = {'access_token': self.key}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            request = requests.get(url, params = params)
        else:
            if query_method == 'post': 
                request = requests.post(url, params=params, json={}, headers=headers)
            else:
                request = requests.put(url, params=params, json={}, data=data)
                
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + " operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request
        
    #+end_src

    
** Step 2: initremote.
   "Gets called when git annex initremote or git annex enableremote are
   run. This is where any one-time setup tasks can be done, for
   example creating the remote folder. Note: This may be run
   repeatedly over time, as a remote is initialized in different
   repositories, or as the configuration of a remote is changed."
   
   We can fetch the access token (given by the user as an argument
   while initializing the remote) by using the function getconfig.  
   We then create an upload by sending a post request to the API. 
   We fetch the id of the bucket and the url of the bucket so that we
   can use it in the other functions.
   
    #+begin_src python :results output :exports both
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        import requests
        # need to get the key by using the getconfig method
        # the key is passed as an argument when using the commant initremote (ex: key='')
        self.key = self.annex.getconfig('key')
        # if it's not been added as an argument, we raise an 
        if not self.key:
            raise RemoteError("You need to add the access token (key = TOKEN)")

        # now, we need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        if r.status_code > 204:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a post query to the API')
        
        # setting the id for this deposit
        self.deposit = r
        self.deposit_id = r.json()['id']
        self.deposit_bucket = r.json()['links']['bucket']
        
    #+end_src

    
** Step 3: prepare.
    "Tells the remote that it's time to prepare itself to be used. Gets
    called whenever git annex is about to access any of the below
    methods, so it shouldn't be too expensive."

    We send a get request to the API just to make sure that the
    connection to the API is well established and that there is no
    problem with the access token for instance.

    #+begin_src python :results output :exports both
      def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use
          
        import requests
        # let's try to connect to the API, if the status code is not 200: there is an error 
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')
        
    #+end_src    

    
** Step 4: transferstore.
"Store the file in localfile to a unique location derived from key."

We only need to upload the file into the deposit. This is done by
getting the url of the deposit that was created and by then making a
put request to the API to send the file.
    
    #+begin_src python :results output :exports both
    def transfer_store(self, key, filename):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        try:
            # fetching the url of the bucket
            URL_BUCKET = self.deposit_bucket

            # and then we upload it

            #filename = 'notes.pdf'
            #path = '/home/nubudi/Downloads/notes.pdf'

            # extracting the filename and the path from filename
            # the argument filename of the function contains the full path to the path.
            # we  can get the name of the file by using the function rsplit to split 
            # the string at the specified separator '/' and we can get the filename by 
            # getting the lest element of the file.
            list = filename.rsplit("/")
            file = list[-1]
            path = filename

            # The target URL is a combination of the bucket link with the desired filename
            # seperated by a slash.
            with open(path, "rb") as fp:
                r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
            
            if r.status_code < 400:
                print("finished exporting the file... \n")
            else:
                raise RemoteError ('error while exporting the file... \n')

        except Exception as error:
            raise RemoteError(error)
    #+end_src

    
** Step 5: transferretrieve.
"Get the file identified by key from the remote and store it in
localfile."

We check if the file exists by comparing the key (= the name of the
file in this case) and then we send a get request to check information
on the file.

#+begin_src python :results output :exports both

#+end_src

      #+begin_src python :results output :exports both
    def checkpresent(self, key, filename):
        # return True if the key is present in the remote
        # return False if the key is not present
        # raise RemoteError if the presence of the key couldn't be determined, eg. in case of connection error

        try:
            url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
            r = self.query('get', url)
            # going through the list of the files in this deposit
            for i in range(len(r.json())):
                if r.json()[i]['filename'] == key:
                    url = r.json()[i]['links']['download']
                    r = self('get', url)   
        except Exception as error:
            raise RemoteError(error)

      #+end_src

      
** Step 6: checkpresent.
"Requests the remote to check if a key is present in it."

We can compare the key to the files that are already stored in the
deposit and then return true or false depending on the case. If there
is a problem with the determining of this, we can raise an exception.

    #+begin_src python :results output :exports both
    def checkpresent(self, key):
        # return True if the key is present in the remote
        # return False if the key is not present
        # raise RemoteError if the presence of the key couldn't be determined, eg. in case of connection error

        try:
            url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
            r = self.query('get', url)
            # going through the list of the files in this deposit
            for i in range(len(r.json())):
                if r.json()[i]['filename'] == key:
                    print('yes, this file exists in the remote: ' + key )
                    return True
            return False 
            
        except Exception as error:
            raise RemoteError(error)
    #+end_src

    


* Friday 04/06.
** fetching and downloading files.

- Writing this function to fetch a particular file from the the
deposit. This is done by looking up a file in the deposit that has a
name that is the same as the key that is passed to the function. We
can then get other information about this file in the same
response. The url that could be useful is for instance the download
link.

#+begin_src python :results output :exports both
import requests
import json

params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
deposit_id = 846331
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'
r = requests.get(url, params = params)
# going through the list of the files in this deposit
for i in range(len(r.json())):
    # checking if the file exists by comparing the key/filename
    # sending a get request to check information on the file
    if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
        # we can retrieve a single deposition file with: 
        #url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files/' + str(file_id)
        # getting the id of the file that we want to download
        file_id =  r.json()[i]['id']
        # getting the download link of the file
        url = r.json()[i]['links']['download']
        r = requests.get(url, params = params)
        #print(json.dumps(r.json(), indent=4))
        print(r.status_code)
        
#+end_src

#+RESULTS:
: 200


- We can now retrieve the file using the same logic and then writing
  the content of the file into a new file locally.
  
#+begin_src python :results output :exports both
import requests
import json

params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
deposit_id = 846331
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'
r = requests.get(url, params = params)
# going through the list of the files in this deposit
for i in range(len(r.json())):
    # checking if the file exists by comparing the key/filename
    # sending a get request to check information on the file
    if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
        # getting the id of the file that we want to download
        file_id =  r.json()[i]['id']
        # getting the download link of the file
        url = r.json()[i]['links']['download']
        
        r = requests.get(url, params = params, stream=True)
        r.raise_for_status()
        print(r.status_code)
        with open("test_download", "wb") as f:
            for chunk in r.iter_content(chunk_size=120): 
                f.write(chunk)
        f.close()

#+end_src

#+RESULTS:
: 200

By implementing in the function transferretrieve, we can now retrieve
the files we want from the remote just by giving the key (ie the name
of the file) and the path where we want it to be stored. This is how
the function looks now:

#+begin_example
    def transfer_retrieve(self, key, filename):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
        import json

        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)

        # going through the list of the files in this deposit
        for i in range(len(r.json())):
            # checking if the file exists by comparing the key/filename
            # sending a get request to check information on the file
            if r.json()[i]['filename'] == key:
                # we can retrieve a single deposition file with: 
                # url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files/' + str(file_id)
                # getting the id of the file that we want to download
                file_id =  r.json()[i]['id']
                # getting the download link of the file
                url = r.json()[i]['links']['download']
                r = self('get', url, stream = True)        
                r.raise_for_status()
                # storing the file in the path given in filename
                # this is done by reading the content of the file and writing it in the new file
                # if the files are very large, we can make the chunk size bigger 
                with open(filename, "wb") as f:
                    for chunk in r.iter_content(chunk_size=120): 
                        f.write(chunk)
                # once we finish writing into the file we can close it
                f.close()

        if r.status_code > 204:
            print("error while fetching the file from the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')

#+end_example




** deleting a file.
- First, we have to have the id of a deposit that isn't published to
  be able to delete files. So, we can create a deposit easily with a
  post request or directly via the the sandbox website. We then fetch
  the id of this deposit (ie: 848907) and we go through the list of
  the files that are stored in the deposit and compare their title to
  the key (we can use the url /api/deposit/depositions/:id/files).
  We also have to retrieve the id of the file and append it the url to
  be able to access this file directly. Lastly, we can send a delete
  request to the API to delete it.
     + The Success response that we want: 204
     + Error response: 403 / 404
  
#+begin_src python :results output :exports both
import requests
import json

# the id of the deposit where we want to delete the file
deposit_id = 848907
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}

r = requests.get(url, params=params)

# going through the list of the files in this deposit
file_id = None
for i in range(len(r.json())):
    if r.json()[i]['filename'] == 'notes.pdf':
        file_id = r.json()[i]['id']
        
# Delete an existing deposition file resource. Note, only deposition 
# files for unpublished depositions may be deleted.

# first, we update the url so as to use it to delete the file
url = url + '/' + str(file_id)

# we then make the query to delete the file
r = requests.delete(url, params=params)
print(r.status_code)

#+end_src

#+RESULTS:
: 204

As we can see, the response code is 204 which means that the request
was successfully executed and that the file was deleted. We can also
check this by looking up the url of the deposit on
https://sandbox.zenodo.org/deposit/848907 or by sending a get request
to the API.
We implement this into the remove function so as to delete files from
the deposit.



** Step 7: remove.
"Requests the remote to remove a key's contents."

We first look in the list of the exported files to see if the file
whose name corresponds with the key exists in that deposit. Then, we
fetch the id of the file. Now, we can delete the file using the delete
query (this could only be done to unpublished depositions seeing that
we can not edit pblished ones).
The status code that we want to get in response is 204, so we can
look into that to make sure that the operation was done successfully. 

      #+begin_src python :results output :exports both
    def remove(self, key):
        # remove the key from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        # checking if the key exists in the remote deposit
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        file_id = None
        for i in range(len(r.json())):
            if r.json()[i]['filename'] == key:
                file_id = r.json()[i]['id']

        # if the key is non existing, we shouldn't raise an exception        
        if file_id is None:
            return
        
        # Delete an existing deposition file resource. Note, only deposition 
        # files for unpublished depositions may be deleted.

        # first, we update the url so as to use it to delete the file
        url = url + '/' + str(file_id)
        # we then make the query to delete the file
        r = self.query('delete', url)

        # raising RemoteError if there is a problem with the removal of the file
        if r.status_code > 204:
            print("error while deleting the file from the remote" + str(r.status_code))
            raise RemoteError('could not send a delete query to the API')
   
      #+end_src

      
** Step 8: transferexportstore.
"Requests the transfer of a file on local disk to the special
remote. Note that it's important that, while a file is being stored,
checkpresentexport() not indicate it's present until all the data has
been transferred. While the transfer is running, the remote can send
any number of progess(size) messages."

We have already implemented a function that does the job of uploading
files into the deposit. So all we have to do now is to use this
function by calling it here and giving as arguments the names of the
remotefile and the localfile. By giving the name of the remotefile as
key, we set the keys as the name of the files which facilitates the
search.

       #+begin_src python :results output :exports both
    def transferexport_store(self, key, local_file, remote_file):
        # store the file located at `local_file` to `remote_file` on the remote
        # raise RemoteError if the file couldn't be stored

        return self.transfer_store(remote_file, local_file)

       #+end_src

       
** Step 9: transferexportretrieve.
"Requests the transfer of a file from the special remote to the local
disk. Note that it's important that, while a file is being stored,
checkpresentexport() not indicate it's present until all the data has
been transferred. While the transfer is running, the remote can send
any number of progess(size) messages."

We have already implemented a function that does the job of fetching
and downloading files from the deposit. So all we have to do now is to use this
function by calling it here and giving as arguments the names of the
remotefile/key and the localfile.
Seeing that the key in this case is the same as the name of the
remotefile we can use either of them.

      #+begin_src python :results output :exports both
    def transferexport_retrieve(self, key, local_file, remote_file):
        # get the file located at `remote_file` from the remote and store it to `local_file`
        # raise RemoteError if the file couldn't be retrieved

        return self.transfer_retrieve(key, local_file)
      #+end_src
  


** Step 10: checkpresentexport.
"Requests the remote to check if the file is present in it."

We use the function checkpresent which we have already implemented to
look in the remote deposit for the file whose key corresponds to the
one given. 

      #+begin_src python :results output :exports both
    def checkpresentexport(self, key, remote_file):
        # return True if the file `remote_file` is present in the remote
        # return False if not
        # raise RemoteError if the presence of the file couldn't be determined, eg. in case of connection error
        
        return self.checkpresent(key)
      #+end_src

      
** Step 11: removeexport.
"Requests the remote to remove content stored by
transferexportstore()."

We use the remove function to look into the list of the uploaded files
and to remove the file whose key corresponds to the one given here.

      #+begin_src python :results output :exports both
    def removeexport(self, key, remote_file):
        # remove the file in `remote_file` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        return self.remove(key)
      #+end_src


* Monday 07/06.
** Step 12: removeexportdirectory.
 "Requests the remote to remove an exported directory. If the remote
 does not use directories, or removeexport() cleans up directories
 that are empty, this does not need to be implemented."

 We can use this function to remove all files from the deposit seeing
 that we don't have multiple directories in a Zenodo deposit. So to do
 this, we will need to look into the list of the uploaded files, and
 fetch the id of each of the files and then send a delete query to the
 url containing the id of this file (ex: 'url/files/id'). 
 
      #+begin_src python :results output :exports both
    def removeexportdirectory(self, remote_directory):
        # remove the directory `remote_directory` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing directory isn't considered an error

        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        file_id = None
        # manipulating each of the files in this deposit
        for i in range(len(r.json())):
            file_id = r.json()[i]['id']
            if file_id is not None:     
                # Delete an existing deposition file resource. Note, only deposition 
                # files for unpublished depositions may be deleted.
                # first, we update the url so as to use it to delete the file
                url = url + '/' + str(file_id)
                # we then make the query to delete the file
                r = self.query('delete', url)
                # for each of the files
                # raising RemoteError if there is a problem with the removal of the file
                if r.status_code > 204: 
                    print("error while deleting the " + str(i) + " file from the remote" + str(r.status_code))
                    raise RemoteError('could not send a delete query to the API')
      #+end_src


** Test: renaming unpublished files on Zenodo.
*** Renaming using the edit action.
We can use the action edit to try to edit the name of the file we want
to rename. So, first we need to send a get query to get all the
information about the deposit, before sending the edit query to make
the changes we want to make.
 
#+begin_src python :results output :exports both
    params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
    deposit_id = 851823
    url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'

    # first: the get request
    r = requests.get(url, params = params)
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    print()

    # second: the post request with the edit action to unlock the deposition for editing
    r = requests.post('https://zenodo.org/api/deposit/depositions/' + str(deposit_id) +'/actions/edit', params=params, json={})
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    print()

    r = requests.post('https://zenodo.org/api/deposit/depositions/' + str(deposit_id) +'/actions/discard', params=params, json={})
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    print()

"""
    # going through the list of the files in this deposit
    for i in range(len(r.json())):
        # checking if the file exists by comparing the key/filename
        # sending a get request to check information on the file
        if r.json()[i]['files']['filename'] == 'AirPollutionInGrenoble.pdf':
          
    """  
#+end_src

#+RESULTS:

*** Renaming using the Update action.
https://github.com/zenodo/zenodo/issues/1459

#+begin_src python :results output :exports both
import json
import requests

deposit_id = '851823'
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'

# first, we get the id of the file we want to name
r = requests.get(url, params = params)
print(r.status_code)

for i in range(len(r.json())):
    if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
        file_id = r.json()[i]['id']
        break;

url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ deposit_id + '/files/' + file_id
headers = {"Content-Type": "application/json"}
data = {"name": "airpollutionstudy.pdf"}

r = requests.put(url, data=json.dumps(data), params = params, headers=headers, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))
#+end_src

#+RESULTS:
: 200
: 400
: {
:     "status": 400,
:     "message": "Wrong file on input."
: }

*** Another try with the put request.

#+begin_src python :results output :exports both
def rename_file():
    # trying to rename the file in a different way
    import json
    import requests

    headers = {"Content-Type": "application/json"}
    deposit_id = '851823'
    params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
    url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ deposit_id + '/files'

    # first, we get the id of the file we want to name
    r = requests.get(url, params = params)
    print(r.status_code)

    # getting the id of the file
    for i in range(len(r.json())):
        if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
            file_id = r.json()[i]['id']
            break;

    # first, we get the id of the file we want to name
    url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ deposit_id + '/files/' + file_id 
    r = requests.get(url, params = params)
    print(r.status_code)
   
    file_desc = r.json()
    if file_desc['filename'] != 'airpollutionstudy.pdf':
        r = requests.put(file_desc['links']['self'], json={'name': 'airpollutionstudy.pdf'}, params=params, headers= headers )
        print(r.status_code)
        print(json.dumps(r.json(), indent=4))


rename_file()
#+end_src

#+RESULTS:
: 200
: 200
: 400
: {
:     "status": 400,
:     "message": "Wrong file on input."
: }


** Step 13: renameexport.
 "Requests the remote rename a file stored on it from filename to
 newfilename. Remotes that support exports but not renaming do not
 need to implement this."
 
      #+begin_src python :results output :exports both

      #+end_src

      
** Step 14: publishing.
*** The things that need to be tackled.
To publish a deposit on Zenodo using the API we can use the publish
action but we need to add some information to the deposit
metadata. The required data depend on what type of publication we need
to do and sometimes extra information needs to be given.
Here is an example of the basic data to add using a put request before
publishing:

#+begin_example
data = {
     'metadata': {
         'title': 'example',
         'upload_type': 'poster',
         'description': 'first upload',
         'creators': [{'name': 'lastname, firstname',
                       'affiliation': 'Zenodo'}]
     }
}

#+end_example

Here are the required attributes to specify:

#+begin_example

- upload_type:
   + publication
   + poster
   + presentation
   + dataset
   + image
   + video
   + software
   + lesson
   + physicalobject
   + other
- publication_date.
- title.
- creators: name (optional: affiliation / orcid / gnd)
- description.
- access_right: open / embargoed / restricted / closed.
- license (if access_right = open | embargoed): "The selected license applies 
to all files in this deposition, but not to the metadata."
- embargo_date (if access_right = embargoed): "When the deposited files will 
be made automatically made publicly available by the system. 
Defaults to current date."
- access_conditions (if access_right = restricted): "Specify the conditions 
under which you grant users access to the files in your upload. User requesting 
access will be asked to justify how they fulfil the conditions. Based on the 
justification, you decide who to grant/deny access."
- publication_type (if upload_type = publication):
   + annotationcollection
   + book
   + section
   + conferencepaper
   + datamanagementplan
   + article
   + patent
   + preprint
   + deliverable
   + milestone
   + proposal
   + report
   + softwaredocumentation
   + taxonomictreatment
   + technicalnote
   + thesis
   + workingpaper
   + other
- image_type (if upload_type = image):
   + figure
   + plot
   + drawing
   + diagram
   + photo
   + other
#+end_example

So, keeping these restrictions in mind, we can take the basic publish
function we have written and add all these information into it.

We can devise the functionalities done by the publish function into
multiple methods that we can call whenever a task is needed to be
completed.

*** Setting the type of the upload.
In this case, we will need to ask the user the type of the update as
well as some extra information in the case of some types that require
them.

#+begin_src python :results output :exports both
    # function to call whenever we can to choose an upload type:
    def setting_uploadtype(self):
        # the possible types of the uploads
        uploadtypes = ['publication', 'poster', 'presentation', 'dataset', 'image', 
                        'video', 'software', 'lesson', 'physicalobject', 'other']

        # in the case: upload_type == 'publication'
        publicationtypes = ['annotationcollection', 'book', 'section', 'conferencepaper', 'datamanagementplan', 
                            'article', 'patent', 'prepint', 'deliverable', 'milestone', 'proposal', 'report', 
                            'softwaredocumentation', 'taxonomictreatment', 'technicalnote', 'thesis', 'workingpaper', 'other']
        # in the case: upload_type == 'image'
        imagetypes = ['figure', 'plot', 'drawing', 'diagram', 'photo', 'other']

        # asking for the initial type of the upload:
        print("What is the type of the upload? Please choose one of these options (ex: 5) \n")
        print("0 - publication \n")
        print("1 - poster \n")
        print("2 - presentation \n")
        print("3 - dataset \n")
        print("4 - image \n")
        print("5 - video \n")        
        print("6 - software \n")
        print("7 - lesson \n")
        print("8 - physical object \n")
        print("9 - other \n")
        n = int(input('Enter the correspoding number: '))
        upload_type = uploadtypes[n]
        
        # taking care of the information concerning the publication type:
        if upload_type == 'publication':
            print('Here are the possible types of publication. Please choose one of them (ex: 5) \n')
            print("0 - annotation collection \n")
            print("1 - book \n")
            print("2 - section \n")
            print("3 - data management plan \n")
            print("4 - article \n")
            print("5 - patent \n")
            print("6 - preprint \n")
            print("7 - deliverable \n")
            print("8 - milestone \n")
            print("9 - proposal \n")
            print("10 - software documentation \n")
            print("11 - taxonomic treatment \n")
            print("12 - technical note \n")
            print("13 - thesis \n")
            print("14 - working paper \n")
            print("15 - other \n")
            n = int(input('Enter the correspoding number: '))
            upload_type = publicationtypes[n]

        elif upload_type == 'image':
            print('Here are the possible types of images. Please choose one of them (ex: 5) \n')
            print("0 - figure \n")
            print("1 - plot \n")
            print("2 - drawing \n")
            print("3 - diagram \n")
            print("4 - photo \n")
            print("5 - other \n")
            n = int(input('Enter the correspoding number: '))
            upload_type = imagetypes[n]
        
        return upload_type 
#+end_src

*** Setting the list of the creators.
Since some publications have multiple authors, we need to use a list
containing information about all of them instead of using a single
dictionary with the required attributes as the keys.
We initialize an empty list and then we ask the user to give
information about each one of the creators. Some of the attributes are
required (familyname and givenname) whereas others can be given
optionally. After receiving the values, we can finally add the
attributes as keys and the values into a dictinnary which will be
stocked in the list. This is done for each creator.

#+begin_src python :results output :exports both
    def setting_creators(self):
        creators = []
        c = {}
        nbcreators = int(input("Enter the number of the creators of this upload. \n"))
        for i in range(nbcreators):
            print("For the " + str(i) + " creator: \n")
            family_name = input('Enter the Family name (Required): \n')
            given_name = input('Enter the Given name (Required): \n')
            affiliation = input('Enter the affiliation of the creator or press enter to pass (Optional): \n')
            orcid = input('Enter the orcid of the creator or press enter to pass (Optional): \n')
            gnd = input('Enter the gnd of the creator or press enter to pass (Optional): \n')
            c['name'] = "%s, %s" % (family_name, given_name)
            if affiliation != '':
                c['affiliation'] = affiliation
            if orcid != '':
                c['orcid'] = orcid
            if gnd != '':
                c['gnd'] = gnd
            creators.append(c)

        return creators
#+end_src

*** Setting the access rights.
This function to call to set the access right to the publication. The
user chooses which type of access to give and takes care of any
additional information that depends on the chosen access.

For instance, when we want to create a new version of a deposit
without having to make it publicly available (seeing that it needs to
be published), we can publish it while choosing the accessright as
closed. This will allow us to manipulate the new version however we
please while still keeping the content closed.

#+begin_src python :results output :exports both
    def setting_accessright (self):
        
        # initializing the list of options
        accessrights = ['open', 'embargoed', 'restricted', 'closed']
        licenses = ['Creative Commons Attribution 4.0 International', 'Creative Commons Attribution 1.0 Generic', 
                    'Creative Commons Attribution 2.0 Generic', 'Creative Commons Attribution 3.0 Unported']
        
        # choosing the access right 
        print("What is the access right of the upload? Please choose one of these options (ex: 2) \n")
        print("0 - open \n")
        print("1 - embargoed \n")
        print("2 - restricted \n")
        print("3 - closed \n")        
        n = int(input('Enter the correspoding number: '))
        access_right = accessrights[n]        

        # taking care of the extra information concerning all the possible access rights
        
        if access_right == 'embargoed':
            # need to specify embargo_date
            print('Specify the Embargo date. The format is: YYYY-MM-DD. \n')
            embargo_date = input()

        if access_right == 'embargoed' or access_right == 'open':
            # need to specify the license
            print('Specify the license. Choose one of these options: \n')
            print("0 - Creative Commons Attribution 4.0 International \n")
            print("1 - Creative Commons Attribution 1.0 Generic \n")
            print("2 - Creative Commons Attribution 2.0 Generic \n")
            print("3 - Creative Commons Attribution 3.0 Unported \n")               
            n = int(input('Enter the correspoding number: ')) 
            license = licenses[n]

        if access_right == 'restricted':
            # need to specify access_conditions
            print('Specify the conditions under which you grant users access to the files in your upload. \n')
            access_conditions = input()

#+end_src

*** Getting the licenses.
if we need to get all the possible licenses, we can send a get query
to api (url: /api/licenses/') and we will get in response a list
containing all the licenses with extra information.

#+begin_src python :results output :exports both
def list():
    import requests
    import json
    r = requests.get('https://sandbox.zenodo.org/api/licenses/')
    print(json.dumps(r.json(), indent=4))  

list()
#+end_src





* Tuesday 08/06.
- checksum: look into storing it when we  upload a file into zenodo so
  that we can compare it to the checksum and know the versions when we
  want to check later.

- if we want to keep the hierarchy of the files and the folders when
  we upload them, there is a problem seeing that zenodo doesn't
  support folders. If we add an archive when we upload to keep the
  state of the repository when we upload it (we can publish the
  content of the git repository as a zip).

  have a file (script) that keeps the right place for each of the
  files. We can store the correct hierarchy of the files in this file
  that is written in a simple format. 

-  git annex init zenodo: when we init a new version of a deposit for
  example we have to find a way to keep a link between the files that
  we have already published and the versions of these files that are
  in the new deposit. We can for instance look in the list of the
  annexed files and compare the ids of these files that have already
  been annexed in an old deposit and make a new link with the copies
  of these files that are in the new version of the deposit. (ex: git
  annex init zenodo --from id)

  the flow of the commands:
  git annex init zenodo --from id
  git annex add
  git annex sync
  git tree-to-zenodo --bucket-id     // doesn't really go through git
  annex, we can do this before publishing the deposit so that we can
  add the file that keeps the state of the repository 
  git annex zenodo-to-web

  We can remove the command to take care of uploading the tree to
  zenodo and add an option instead to the zenodo-to-web command
  (--with-tree --with-link) where we add a file / zip containing the
  git information about this file and the sym link referencing each
  one of the files.

  If there is a problem for instance when we upload a file that isn't
  referenced we can for example (git annex remove-unreferenced --backend-zenodo) which removes
  the files from the deposit that aren't referenced and that don't
  have a symbolic link for us to reach them later on. 

  We can have this as the blueprint of the list of commands to make
  when we want to manipulate the datasets/files and upload them into
  zenodo while still keeping the heirarchy of the files and the
  referencing the git symbolic links that they have been annexed with
  so as to be able to reuse them if we for instance want to init a new
  version of a deposit:
  
  git annex init zenodo --from id
  git annex add
  git annex sync
  git annex remove-unreferenced --backend-zenodo
  git annex zenodo-to-web

  Look into a command that adds referenced / remove unreferenced
  automatically for all the backend remotes in git annex. ! 

- for the publishing step we can create a file where we set up all the
  necessary information to give to the api to be able to
  publish. Instead of asking for the user to insert all the details
  while passing the command, we can keep a json file containing all
  this information and then just read from it when we want to sent the
  put query to the API before we publish.

- For datalad the issue had been discussed as to how to add this
  functionality to datalad when working with some remotes that don't
  really support directories and file hierarchy. For instance, the use
  of git/refs or git-repo.zip could be interesting to upload with the
  flat hierarchy.  
    + link: https://github.com/datalad/datalad/issues/5221
  
- RIA:
  https://github.com/datalad/datalad/blob/master/datalad/distributed/create_sibling_ria.py
  http://handbook.datalad.org/en/latest/beyond_basics/101-147-riastores.html

- to do:
+ play a little with remote directory to see how it works / the
  representation of the data and the functioning of the commands.
+ keep looking into Datalad issues to see if Zenodo was mentionned by
  someone and if yes see why it's not been looked into as a possible
  special remote.
+ look at how the datalad export-to-figshare is implemented. 
  
- We can have a method (ex: getrefs) that gets the references that are
  kept in a dedicated file in the remote.
 
- For bigger datasets why not also upload the files that are at the
  top of the hierarchy first and then upload the subdirectories as
  archives later on.

- "An ideal "data publishing/hosting" should allow both push/pull
  (download/publish) for any of the files while retaining original
  directory structure. Then interactions could be established back at
  the level of git-annex itself, like it does e.g. for S3 now. And if
  download of a full or subset is needed - would generate
  (reproducibly, so sorting the files and injecting consistent archive
  header) a zipball on the fly."

- 



* Wednesday 09/06.

- Looking into possible example of implementation of Zenodo as a
  remote for Datalad: There hasn't been any addition to the
  implementation of this remote since the initial idea of making it.
  There is, however, a crawler implemented by CONP to facilitate the
  uploads to the database. This is done by uploading the files and the
  datasets into Zenodo (using the ZenodoCrawler, cf:
  https://github.com/CONP-PCNO/conp-dataset/blob/master/scripts/Crawlers/ZenodoCrawler.py
  which implements methods from the Basecrawler library).
  This crawler is used specifically to crawl data from the Zenodo
  remote and to update the conp database whenever there are
  changes. This is done by retrieving the metadata from the conp
  dataset (conceptdoi and versiondoi most importantly) and then
  getting all the metadata from the zenodo datasets that are related
  to conp (this could be done by comparing the keywords). And for each
  of the datasets retrieved from Zenodo we can look to see if it
  already exists in the conp database: if this is the case, we update
  it if it's a new version (this is done by comparing the conp
  versiondoi to the zenodo latestversiondoi). If it doesn't figure in
  the database (we can know this by comparing the conceptdoi of the
  dataset from Zenodo to the one that we have retrived from conp), we
  can then download the Zenodo dataset into a new Datalad dataset and
  update the collection.
  This is explained here:
  https://github.com/CONP-PCNO/conp-dataset/issues/79

- How Datalad implements the figshare export: the content of datasets
  is exported to figshare after having been made into a zip archive
  because figshare doesn't allow file hierarchy and doesn't support
  directories (which is also the case for Zenodo). This also hinders
  the use of git annex special remotes seeing that it's impossible to
  publish complete directories. Following this path, Datalad
  implemented a way to navigate the zip archives that are exported to
  figshare so as to be able to manipulate them.

  https://github.com/datalad/datalad/blob/master/datalad/distributed/export_to_figshare.py
  
  
- While initializing the remote on git annex, we can set up the uuid
  as well by getting it from git annex with the getconfig
  function. With this we can keep a link between the remote deposit we
  will be creating with initremote and the identifier of the local
  git-annex directory (ex: self.uuid = self.annex.getconfig('uuid')).

- version controlling: The git-annex tool is a distributed system that can manage and
  share large files independent from a central service or
  server. git-annex manages all file content in a separate directory
  in the repository (.git/annex/objects, the so-called annex) and
  only places file names with some metadata into version control by
  Git. When a Git repository with an annex is pushed to a web-hosting
  service such as GitHub, the contents stored in the annex are not
  uploaded. Instead, they can be pushed to a storage system.
  If a repository with an annex is cloned, the clone will not
  contain the contents of all annexed files by default, but display
  only file names. This makes the repository small, even if it tracks
  hundreds of gigabytes of data, and cloning fast, while file
  contents are stored in one or more free or commercial external
  storage solutions.
  Versions can be controlled when uploaded to Zenodo because of the
  doi id that is given by Zenodo once a record has been
  published. Knowing this, we can track the versions of a record as we
  edit it or update it.
  We can get all versions with the concept doi so this means we will
  have access to all versions of our record to look through whenever
  needed. This could also help us when we want to see if the published
  version of a record that's been uploaded through the API to Zenodo
  is the same as the version we have locally. We can have a function
  that looks into this whenever needed.
  What is DOI versioning?
  
- Pointers on the DOI versioning:
  + DOI versioning allows you to:
    edit/update the record’s files after they have been published.
    cite a specific version of a record.
    cite all of versions of a record.
  + How does DOI versioning work?
    When you publish an upload on Zenodo for the first time, we
    register two DOIs:
    a DOI representing the specific version of your record.
    a DOI representing all of the versions of your record.
    Afterwards, we register a DOI for every new version of your upload.
    This is best illustrated by an example of a software package. If
    the software has been released in two versions (v1.0 and v1.1) on
    Zenodo, then the following DOIs would have been registered:
       v1.0 (specific version): 10.5281/zenodo.60943
       v1.1 (specific version): 10.5281/zenodo.800648
       Concept (all versions): 10.5281/zenodo.705645
    The first two DOIs for versions v1.0 and v.1.1 represent the specific
    versions of the software. The last DOI represents all the versions of
    the given software package, i.e. the concept of the software package
    and the ensemble of versions. We therefore also call the them Version
    DOIs and Concept DOIs (note, technically both are just normal DOIs).

  


* Thursday 10/06.
** A new start.
- When we initialize a new deposit on Zenodo, do one of these things:
  + We initialize an empty deposit by creating a new one simply by
    using the normal methods of creation and then we can also set up
    the uuid of the deposit as well by getting it with the function getconfig. With this we can keep a link between the remote deposit we
    will be creating with initremote and the identifier of the local
    git-annex directory.
  + We can initialize a new version of a deposit (we can have an
    argument to specify the id of the deposit (in this case the id of
    the record since it's published) and then we can create the new
    version and retieve the id of the new deposit for later use.
    We also have to find a way to keep a link between the files that
    we have already published (we can get their id and the version doi
    of the record easily) and the files we have in this new deposit.
    A way to do this is to look through the list of the annexed files
    (this tracking is done by git-annex) and compare the ids of these
    files to the new ones to make a link between the two (we can know
    that a file X has been published in the record Y and it's the same
    file that's uploaded to the deposit Z).
 - To upload files, there are different possible implementations:
  + Having a deposit where all the files are uploaded directly without
    taking care of their hierarchy. Since Zenodo doesn't allow
    uploading folders, we can only have a flat architecture inside the
    deposits, which will be a problem when working with already
    defines folders. This is what we have been doing so far by just
    uploading the chosen files into the initiated deposit. This
    implementation facilitatesthe tasks of uploading and looking
    through the list of documents.
  + Follow the Datalad example and export the files into the remote as
    archives. This would keep the hierarchy of the files and we can
    have a function that takes care of navigating the chosen files (or
    the folder) and turns them into a zip archive. git-annex should
    also still be able to track these files by using this method.
    datalad works with this method because it manipulates entire
    datasests so when the user wants to fetch and download their
    dataset, they cant use a datalad get command to retrieve the whole
    archive. When it comes to single files, this could be a problem
    since we will be wanting to fetch and download a single file of
    the deposit sometimes and to do this, we will have to be able to
    work with them individually when searching and downloading.
  + Add an archive when we upload to keep the state of the repository
    when we upload it (we can publish the content of the git
    repository as a zip). Have a file (script) that keeps the right
    place for each of the files. We can store the correct hierarchy of
    the files in this file that is written in a simple format.
      
** Making changes in the classe.

  - Choosing if the user wants to use the sandbox or the official
    website of Zenodo tp create the remote. Passing an argument
    url=zenodo for instance if they want to use zenodo.
    We can then fetch the argument when we want to initiate the deposit
    and create the it accordingly.

  + initremote change1:
  #+begin_src python :results output :exports both
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        import requests
        
        # need to get the key by using the getconfig method
        self.key = self.annex.getconfig('key')
        
        # getting the url of the remote (Zenodo or Sandbox)
        # the user would need the key for both of them and it's created on the website of the one they chose
        if self.annex.getconfig('url') is None:
            self.url = 'https://zenodo.org/api/deposit/depositions'
        else:
            self.url = 'https://sandbox.zenodo.org/api/deposit/depositions'

        # the key is passed as an argument when using the commant initremote (ex: key='')
        # if it's not been added as an argument, we raise an 
        if self.annex.getconfig('key') is None:
            raise RemoteError("You need to add the access token (key = TOKEN)")

        # now, we need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        if r.status_code > 204:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a post query to the API')
        
        # setting the id for this deposit
        self.deposit = r
        self.deposit_id = r.json()['id']
        self.deposit_bucket = r.json()['links']['bucket']
  #+end_src
  
  - We also need to use the method setconfig when we fetch all the
    important arguments (sent by the user in the command
    initremote). This allows these settings to be stored in the
    git-annex branch, so will be available if the same special remote
    is used elsewhere. We can do this during initremote() so that we
    can use the settings after since the changes will only be
    available while the remote is running if we use setconfig after
    initremote(). 
        
   + initremote change2:
    #+begin_src python :results output :exports both
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        import requests
        
        # need to get the key by using the getconfig method
        self.key = self.annex.getconfig('key')
        
        # getting the url of the remote (Zenodo or Sandbox)
        # the user would need the key for both of them and it's created on the website of the one they chose
        if self.annex.getconfig('url') is None:
            self.url = 'https://zenodo.org/api/deposit/depositions'
        else:
            self.url = 'https://sandbox.zenodo.org/api/deposit/depositions'

        # the key is passed as an argument when using the commant initremote (ex: key='')
        # if it's not been added as an argument, we raise an 
        if self.annex.getconfig('key') is None:
            raise RemoteError("You need to add the access token (key = TOKEN)")

        # now, we need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        if r.status_code > 204:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a post query to the API')
        
        # setting the id for this deposit
        self.annex.setconfig('deposit', r)
        self.annex.setconfig('deposit_id', r.json()['id'])
        self.annex.setconfig('deposit_bucket', r.json()['links']['bucket'])
        self.annex.setconfig('url', self.url)
        self.annex.setconfig('key', self.key)
    #+end_src

    
* Friday 11/06.
** continuing with initremote.
   - Now, let's take care of the case of when the user chooses to
     create a new version of a published deposit and work with this
     version. We can do this by adding a setting in the command (ex:
     git annex init zenodo newversion=idoldrecord) where the user specifies the id
     of the record that they want to update. This is also done in the
     initremote function.
     First, let's make sure that the id of the deposit (record in
     this case since it's published) exists, before calling a method
     that creates the new version. We can then set the new config and
     continue working normally with this deposit as we would have any
     other deposit.

   + create newversion:
     #+begin_src python :results output :exports both
def create_newversion(self, oldrecord_id):
    import requests

    # making sure that the given id for the old record is correct
    url = self.url + '/' + str(oldrecord_id) 
    r = self.query('get', url)

    # raise error if there is a problem (the success code is 200)
    if r.status_code != 200:
        raise RemoteError('error while retrieving the old deposit')
    
    # making the post request to create the new version
    url = self.url + '/' +  str(oldrecord_id) + '/actions/newversion'
    r = self.query('post', url)
    
    # raise error if there is a problem (the success code is 201)
    if r.status_code != 201:
        raise RemoteError('error while creating the newversion')

    # fetching the deposition id of the new version
    # we can only access it this way because it's not given as a field
    newdeposit_id = r.json()['links']['latest_draft'].split('/')[-1]

    # making a new get request to get the information about this reposit and returning the response
    url = self.url + '/' + str(newdeposit_id) 
    r = self.query('get', url)
    return r
     #+end_src
     
   + initremote change3:
      #+begin_src python :results output :exports both
    def initremote(self):
        # initialize the remote, eg. create the folders
        # raise RemoteError if the remote couldn't be initialized
        import requests
        
        # need to get the key by using the getconfig method
        self.key = self.annex.getconfig('key')
        
        # getting the url of the remote (Zenodo or Sandbox)
        # the user would need the key for both of them and it's created on the website of the one they chose
        if self.annex.getconfig('url') is None:
            self.url = 'https://zenodo.org/api/deposit/depositions'
        else:
            self.url = 'https://sandbox.zenodo.org/api/deposit/depositions'

        # the key is passed as an argument when using the commant initremote (ex: key='')
        # if it's not been added as an argument, we raise an 
        if self.annex.getconfig('key') is None:
            raise RemoteError("You need to add the access token (key = TOKEN)")

        # now, we need to create an empty upload that we will be using from now on
        # it's either a new version of a deposit or a brand new one
        if self.getconfig('newversion') is not None:
            r = self.create_newversion(self.getconfig('newversion'))
        else:   
            r = self.query('post', self.url)
            
        # making sure that we got the correct success response for creating a new deposit
        if r.status_code != 201:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
                raise RemoteError('could not send a post query to the API')

        # other settings
        self.annex.setconfig('deposit', r)
        self.annex.setconfig('url', self.url)
        self.annex.setconfig('key', self.key)
        # setting the id for this deposit
        self.annex.setconfig('deposit_id', r.json()['id'])
        self.annex.setconfig('deposit_bucket', r.json()['links']['bucket'])
            

      #+end_src
      
** Configs / creds.
   - config Contains the settings which the remote uses (with getconfig() and
     setconfig()) in the form of {'Name': 'Description', …} Note: Name
     must not contain spaces. Description should be reasonably
     short. Example: {'directory': "store data here"} Providing them
     makes git annex initremote work better, because it can check the
     user's input, and can also display a list of settings with
     descriptions. Note that the user is not required to provided all
     the settings listed here.
     So we need to add them to the init function before the function
     initremote is called.
     
   - setting the credentials: since the user doesn't need to give
     their user and password to access the Zenodo remote and only
     needs the access token, should it be stored in the settings
     (setconfig and getconfig) or should we use this instead (setcreds
     and getcreds). 
     Note that creds are normally only stored in the remote's
     configuration when it's surely safe to do so; when gpg encryption
     is used, in which case the creds will be encrypted using it.

   - The list of configs we have:
     configs = {
        'key': "the access token that's needed to do any operation on
     the Zenodo API. Depending on whether the user wants to use the
     sandbox or the official site, they need to create a token (see:
     base/account/settings/applications/)."
        'url': "the url of the site to use when working with this
     remote (could either be zenodo.org or sandbox.zenodo.org). If the
     user wants to work on the sandbox, they need to specify
     url=sandbox. If this is not specified in the command when
     initiating the remote, the official will be used.
        'newversion': "this is optional and is just used if a user
     wants to create a new version of an old record inheriting all its
     files. To use it, the user needs to give the id of the old
     deposit (ex: newversion=111111)
    }

** renaming ressources.
- We will need to implement a function to rename a file because when we
uplad a file, its name gets always saved as the name of the file we
have uploaded locally. The only way to update the name of a file using
the API is by sending  put request containing the new name of the
file.

#+begin_src python :results output :exports both
def test():
    import requests
    import json

    ACCESS_TOKEN = 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'
    headers = {"Content-Type": "application/json"}
    params = {'access_token': ACCESS_TOKEN}

    url = 'https://sandbox.zenodo.org/api/deposit/depositions/851823/files'
    r = requests.get(url, params=params)
    print(json.dumps(r.json(),indent=4))

    for i in range(len(r.json())):
        if r.json()[i]['filename'] == 'draft1_test.txt':
            id = r.json()[i]['id']

    url = url + '/' + str(id)       
    r = requests.put(url, params=params, data={"name": "draft1.txt"}, headers= headers)
    print(json.dumps(r.json(), indent=4))

test()   
    
#+end_src

#+RESULTS:
#+begin_example
[
    {
        "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
        "filename": "AirPollutionInGrenoble.pdf",
        "filesize": 1107977,
        "id": "451b7ec7-32b8-4b80-bb06-beebe2bb043e",
        "links": {
            "download": "https://sandbox.zenodo.org/api/files/0e1bdbfa-07fc-425c-9b6c-ca6636214cde/AirPollutionInGrenoble.pdf",
            "self": "https://sandbox.zenodo.org/api/deposit/depositions/851823/files/451b7ec7-32b8-4b80-bb06-beebe2bb043e"
        }
    },
    {
        "checksum": "b12e26dcfca46531e1bc30a8d4037507",
        "filename": "draft1_test.txt",
        "filesize": 45621,
        "id": "b5f9d7d6-45d6-4763-9363-0d0a33de7a28",
        "links": {
            "download": "https://sandbox.zenodo.org/api/files/0e1bdbfa-07fc-425c-9b6c-ca6636214cde/draft1_test.txt",
            "self": "https://sandbox.zenodo.org/api/deposit/depositions/851823/files/b5f9d7d6-45d6-4763-9363-0d0a33de7a28"
        }
    },
    {
        "checksum": "2d2d364fe89375260446330175bd832f",
        "filename": "notes.pdf",
        "filesize": 180064,
        "id": "71851844-7020-4b59-a046-97901e9a69e0",
        "links": {
            "download": "https://sandbox.zenodo.org/api/files/0e1bdbfa-07fc-425c-9b6c-ca6636214cde/notes.pdf",
            "self": "https://sandbox.zenodo.org/api/deposit/depositions/851823/files/71851844-7020-4b59-a046-97901e9a69e0"
        }
    }
]
{
    "error_id": "b87b276b01e94c10ad2aee3912b05166",
    "message": "Internal Server Error",
    "status": 500
}
#+end_example

There is a problem with this even though it should work according to
the api tutorial.

- The same test but this time on the main zenodo site rather than the
  sandbox. 

  #+begin_src python :results output :exports both
def test():
    import requests
    import json

    ACCESS_TOKEN = '77yLXELtiKqA2OrVWVibQsB3hZsxgIZmDSceLY3FWtCFPCpmC3noTMUSoU1p'
    headers = {"Content-Type": "application/json"}
    params = {'access_token': ACCESS_TOKEN}

    url = 'https://zenodo.org/api/deposit/depositions/4926071/files'
    r = requests.get(url, params=params)
    print(json.dumps(r.json(),indent=4))

    for i in range(len(r.json())):
        if r.json()[i]['filename'] == 'draft1_test.txt':
            id = r.json()[i]['id']

    url = url + '/' + str(id)       
    r = requests.put(url, params=params, data={"name": "draft1.txt"}, headers= headers)
    print(json.dumps(r.json(), indent=4))

test()  
  #+end_src

  #+RESULTS:
  #+begin_example
  [
      {
          "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
          "filename": "AirPollutionInGrenoble.pdf",
          "filesize": 1107977,
          "id": "8105fcef-475c-43b1-b6f6-09028fa0634a",
          "links": {
              "download": "https://zenodo.org/api/files/c5e2b294-582b-4843-962c-1bc7b96e1bca/AirPollutionInGrenoble.pdf",
              "self": "https://zenodo.org/api/deposit/depositions/4926071/files/8105fcef-475c-43b1-b6f6-09028fa0634a"
          }
      },
      {
          "checksum": "b12e26dcfca46531e1bc30a8d4037507",
          "filename": "draft1_test.txt",
          "filesize": 45621,
          "id": "7a27ade3-57c8-4ed3-bfdc-3cf9b2fff1ea",
          "links": {
              "download": "https://zenodo.org/api/files/c5e2b294-582b-4843-962c-1bc7b96e1bca/draft1_test.txt",
              "self": "https://zenodo.org/api/deposit/depositions/4926071/files/7a27ade3-57c8-4ed3-bfdc-3cf9b2fff1ea"
          }
      }
  ]
  {
      "error_id": "553cf106fd674aaa8d3f241930dffccc",
      "message": "Internal Server Error",
      "status": 500
  }
  #+end_example

 The same error.

- editing a desposit using the edit action: when we try to edit a non
  published deposit using this action we get an error so it only works
  on published deposits only.

  #+begin_src python :results output :exports both
def f():
    import requests
    import json

    ACCESS_TOKEN = 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'
    headers = {"Content-Type": "application/json"}
    params = {'access_token': ACCESS_TOKEN}

    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/edit', params = params, json={})
    print(json.dumps(r.json(), indent=4))
f()
  #+end_src

  #+RESULTS:
  #+begin_example
  {
      "conceptdoi": "10.5072/zenodo.846330",
      "conceptrecid": "846330",
      "created": "2021-06-02T13:12:08.831740+00:00",
      "doi": "10.5072/zenodo.846331",
      "doi_url": "https://doi.org/10.5072/zenodo.846331",
      "files": [
          {
              "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
              "filename": "AirPollutionInGrenoble.pdf",
              "filesize": 1107977,
              "id": "8b14ada3-07a2-4da4-a0af-6c18ce58ced4",
              "links": {
                  "download": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca/AirPollutionInGrenoble.pdf",
                  "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files/8b14ada3-07a2-4da4-a0af-6c18ce58ced4"
              }
          }
      ],
      "id": 846331,
      "links": {
          "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846331.svg",
          "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
          "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846330.svg",
          "conceptdoi": "https://doi.org/10.5072/zenodo.846330",
          "doi": "https://doi.org/10.5072/zenodo.846331",
          "latest": "https://sandbox.zenodo.org/api/records/846331",
          "latest_html": "https://sandbox.zenodo.org/record/846331",
          "record": "https://sandbox.zenodo.org/api/records/846331",
          "record_html": "https://sandbox.zenodo.org/record/846331"
      },
      "metadata": {
          "access_right": "open",
          "communities": [
              {
                  "identifier": "zenodo"
              }
          ],
          "creators": [
              {
                  "affiliation": "Zenodo",
                  "name": "H, O"
              }
          ],
          "description": "<p>first upload</p>",
          "doi": "10.5072/zenodo.846331",
          "license": "CC-BY-4.0",
          "prereserve_doi": {
              "doi": "10.5072/zenodo.846331",
              "recid": 846331
          },
          "publication_date": "2021-06-02",
          "title": "Air pollution in Grenoble",
          "upload_type": "poster"
      },
      "modified": "2021-06-11T11:04:19.380341+00:00",
      "owner": 75563,
      "record_id": 846331,
      "state": "inprogress",
      "submitted": true,
      "title": "Air pollution in Grenoble"
  }
  #+end_example

  We can discard the changes with:

    #+begin_src python :results output :exports both
def f():
    import requests
    import json

    ACCESS_TOKEN = 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'
    headers = {"Content-Type": "application/json"}
    params = {'access_token': ACCESS_TOKEN}

    r  = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/discard', params = params, json={})
    print(json.dumps(r.json(), indent=4))
f()    
  #+end_src

  #+RESULTS:
  #+begin_example
  {
      "conceptdoi": "10.5072/zenodo.846330",
      "conceptrecid": "846330",
      "created": "2021-06-02T13:12:08.831740+00:00",
      "doi": "10.5072/zenodo.846331",
      "doi_url": "https://doi.org/10.5072/zenodo.846331",
      "files": [
          {
              "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
              "filename": "AirPollutionInGrenoble.pdf",
              "filesize": 1107977,
              "id": "8b14ada3-07a2-4da4-a0af-6c18ce58ced4",
              "links": {
                  "download": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca/AirPollutionInGrenoble.pdf",
                  "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files/8b14ada3-07a2-4da4-a0af-6c18ce58ced4"
              }
          }
      ],
      "id": 846331,
      "links": {
          "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846331.svg",
          "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
          "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846330.svg",
          "conceptdoi": "https://doi.org/10.5072/zenodo.846330",
          "doi": "https://doi.org/10.5072/zenodo.846331",
          "latest": "https://sandbox.zenodo.org/api/records/846331",
          "latest_html": "https://sandbox.zenodo.org/record/846331",
          "record": "https://sandbox.zenodo.org/api/records/846331",
          "record_html": "https://sandbox.zenodo.org/record/846331"
      },
      "metadata": {
          "access_right": "open",
          "creators": [
              {
                  "affiliation": "Zenodo",
                  "name": "H, O"
              }
          ],
          "description": "<p>first upload</p>",
          "doi": "10.5072/zenodo.846331",
          "license": "CC-BY-4.0",
          "prereserve_doi": {
              "doi": "10.5072/zenodo.846331",
              "recid": 846331
          },
          "publication_date": "2021-06-02",
          "title": "Air pollution in Grenoble",
          "upload_type": "poster"
      },
      "modified": "2021-06-11T11:04:43.725955+00:00",
      "owner": 75563,
      "record_id": 846331,
      "state": "done",
      "submitted": true,
      "title": "Air pollution in Grenoble"
  }
  #+end_example


* Monday 14/06.
Worked with the git-annex-remote-zenodo file and tried to deploy
the remote, initiate it, and test it while making changes to fix the
bugs that arose when trying to init.


* Tuesday 15/06.
** Commands to get the needed information about a file before uploading it to Zenodo.
*** calckey.
Use 'git annex calckey' to calculate the key that would be used to
refer to a file. This could be done to rename the file before adding
it to the annexed files and uploading it to the remote so as to keep
the same names between the two.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd Internship/docs
git annex calckey notes.org
#+END_SRC

#+RESULTS:
: 
: SHA256E-s33173--0aeb5832762f16a00438b5718137c9c61db03628c2ac02f163afb41ac46b5470.org
*** list.
Use the command 'git annex list' to list all the files that have been
annexed in this repository. This also shows which remote contains
files.
*** find.
Or, use the command 'git annex find' which lists all the available
files in this repository. The use of either this or 'list' would
depend on how the user keeps their files and if they keep them in
different remotes all the time or if they have them just here locally
and in Zenodo.
*** info.
Use 'git annex info' with the name of the file to get all the
information concerning an annexed file. This could be useful in the
case where we want to retrieve the key of this file to use it when
uploading it into zenodo.
This is an example where we get all the information available about a
file that's been annexed in a git-annex repository.
  
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/Desktop
git annex info S8/ARI/TP2/Collection_tokens/CACM-1748.flt
#+END_SRC

#+RESULTS:
: 
: file: S8/ARI/TP2/Collection_tokens/CACM-1748.flt
: size: 872 bytes
: key: SHA256E-s872--8358b2a8169727737d6ab442aef4ba53a06e06d6e74d395be911724d15737756.flt
: present: true
*** metadata.
The command 'git annex metadata' could be useful for when we want to get or set
metadata for a file.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex metadata S8/ARI/TP2/Collection_tokens/CACM-1748.flt
#+END_SRC

#+RESULTS:
: metadata S8/ARI/TP2/Collection_tokens/CACM-1748.flt 
: 
: ok

A possible case use in this case is when a user has a lot of annexed
files for different subjects and they want to upload files
concerning obj X to their Zenodo deposit.
Using 'git annex find --metadata tag=X --or --metadata tag=Y' they
could limit the list of files that git-annex looks into when using
the command info.

- To test this, we first add a tag to the metadata of an annexed file
  by using the option -s for 'set'.
  
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex metadata S8/ARI/TP2/Collection_tokens/CACM-1748.flt -s tag=test_metadata
#+END_SRC

#+RESULTS:
: metadata S8/ARI/TP2/Collection_tokens/CACM-1748.flt 
:   lastchanged=2021-06-15@08-27-03
:   tag=test_metadata
:   tag-lastchanged=2021-06-15@08-27-03
: ok
: (recording state in git...)

- Now, we can find the file whose tag corresponds to the we looked for.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex find --metadata tag=test_metadata
#+END_SRC

#+RESULTS:
: S8/ARI/TP/Collection_tokens/CACM-1748.flt
: S8/ARI/TP2/Collection_tokens/CACM-1748.flt

** The succession of commands in this case.
- When we add the file to the annexed files, we can easily retrieve
  the information about this file using the find command (here we have
  to have already set tags to differentiate the topics of the files
  especially when this depository handles a large amount of files),
  and then we can use the info command to get information concerning
  just this file.

  #+begin_example
  git add files
  git commit
  git initremote (w/wo option newversion=id)
  #+end_example

  Then,when we want to do the uploading, we can look into the list of
  the annexed files in this repository (find / list) and use metadata
  to limit the search to the files we are interested in. When we get
  the names of the files, we can use the command info to get all the
  information about them (most importantly in this case, we get the key).

  We can execute these commands, for instance, before uploading a file
  into the deposit:
  #+begin_example
  git annex list (?, + gives info about files that are stored in elsewhere)
  git annex find --metadata tag=example
  git annex info fileX (for each of the files)
  #+end_example

- If we want to do a single upload, we can just look up the name of
  the file in the list of annexed files and then retrieve its key and
  rename it into the key before uploading it to the remote. 

- To be able to execute shell commands (mostly git annex commands)
  from within the python program we can use some libraries that allow
  the interactions between the two.
  + the subprocess library (more flexible/secure than os): https://docs.python.org/3/library/subprocess.html#module-subprocess
  + the os library (basic functionalities): https://docs.python.org/3/library/os.html 
  + the git-annex-adapter library: https://github.com/alpernebbi/git-annex-adapter

  link explaining some differences:
  https://stackoverflow.com/questions/89228/how-to-execute-a-program-or-call-a-system-command-from-python
  
- Test with subprocess:
  this is a simple test that looks to see if there are any untracked
  changes in the git repository and then add the untracked files,
  commits the changes, and pushes into the git remote.

#+begin_src python :results output :exports both
import subprocess
subprocess.run(["ls", "-l"])
subprocess.run("pwd")
subprocess.run(["/usr/bin/git", "status"])
subprocess.run(["/usr/bin/git", "add", "--all"])
subprocess.run(["/usr/bin/git", "commit", "-m", "update"])
subprocess.run(["/usr/bin/git", "push"])
#+end_src

#+RESULTS:
#+begin_example
total 172
drwxr-xr-x 4 nubudi nubudi   4096 juin  15 00:25 code
drwxr-xr-x 2 nubudi nubudi   4096 juin  10 09:44 docs
-rw-r--r-- 1 nubudi nubudi 150784 juin  15 14:43 journal.org
-rw-r--r-- 1 nubudi nubudi  13310 juin   7 09:41 README.md
/home/nubudi/Desktop/Internship
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	deleted:    .#journal.org
	modified:   journal.org

no changes added to commit (use "git add" and/or "git commit -a")
[main 6f8c556] update
 2 files changed, 11 insertions(+), 7 deletions(-)
 delete mode 120000 .#journal.org
#+end_example
   
** Exporting a tree of files.
To do this, we can use the command 'git annex export' so as to store a
tree of files into the special remote. This is especially important in
our case since Zenodo handles a flat architecture of files and so,
when we upload the files (after having changed their name into the key
they were given when they were annexed in the repository) we can lose
the link.
'The treeish to export can be the name of a git branch, or a tag, or
any other treeish accepted by git, including eg master:subdir to only
export a subdirectory from a branch.'

- We need to specify when initializing the remote that we want to
  enable the export function: exporttree=yes since it's automatically
  disabled if not specified. 

link: https://git-annex.branchable.com/git-annex-export/


- Testing export: we will use directory as a special remote and try to
  export a tree to this remote.

creating the directory where we will be testing the export command and
where we will initialize a new directory remote
#+BEGIN_SRC shell :session *shell* :results output :exports both
mkdir tests_export
cd tests_export
pwd
#+END_SRC

#+RESULTS:
: 
: (base) nubudi@ubunto:~/tests_export$ /home/nubudi/tests_export

initiating the git and the git annex repository.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git init
git annex init
#+END_SRC

#+RESULTS:
: Initialized empty Git repository in /home/nubudi/tests_export/.git/
: init  ok
: (recording state in git...)

adding a bunch of files to do the test
#+BEGIN_SRC shell :session *shell* :results output :exports both
cp -R ~/Downloads/writing /home/nubudi/tests_export
#+END_SRC

#+RESULTS:

now we can check the test directory to see that the the other
directory has been copied into it.


#+BEGIN_SRC shell :session *shell* :results output :exports both
ls
cd writing
ls
#+END_SRC

#+RESULTS:
: writing
: (base) nubudi@ubunto:~/tests_export/writing$ drafts  essays  notes


Now, we can add the files to the repository and commit all the
changes.
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ..
git add --all
git commit -m "adding a directory containing a few folders and files into this git repository"
#+END_SRC

#+RESULTS:
: 
: (base) nubudi@ubunto:~/tests_export$ [master (root-commit) 1e38f40] adding a directory containing a few folders and files into this git repository
:  5 files changed, 0 insertions(+), 0 deletions(-)
:  create mode 100644 writing/drafts/_Project Pain.pdf
:  create mode 100644 writing/drafts/the quest for mortality.pdf
:  create mode 100644 writing/essays/OumaimaHajji_5G.pdf
:  create mode 100644 writing/notes/Internship_Notes.pdf
:  create mode 100644 writing/notes/notes.pdf

Now, we can initialize the remote that we will be exporting the tree
of files to.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex initremote myremote type=directory directory=/home/nubudi/tests_export2 exporttree=yes encryption=none
#+END_SRC

#+RESULTS:
: initremote myremote ok
: (recording state in git...)

We export the master branch to the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex export master --to myremote
#+END_SRC

#+RESULTS:
#+begin_example
export myremote writing/drafts/_Project Pain.pdf 
31.98 KiB        10 MiB/s                         ok
export myremote writing/drafts/the quest for mortality.pdf 
31.98 KiB        12 MiB/s                         ok
export myremote writing/essays/OumaimaHajji_5G.pdf 
31.98 KiB        34 MiB/s                         ok
export myremote writing/notes/Internship_Notes.pdf 
31.98 KiB         2 MiB/s                         ok
export myremote writing/notes/notes.pdf 
31.98 KiB         4 MiB/s                         ok
(recording state in git...)
#+end_example


We can check to see if the tree has been exported to the remote.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ..
cd tests_export2
ls
cd writing
ls
#+END_SRC

#+RESULTS:
: 
: bash: cd: tests_export2: No such file or directory
: writing
: (base) nubudi@ubunto:~/tests_export/writing$ drafts  essays  notes

Now, we can go back to the test repository and make changes.
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/tests_export
pwd
#+END_SRC

#+RESULTS:
: 
: /home/nubudi/tests_export

#+BEGIN_SRC shell :session *shell* :results output :exports both
cp ~/Downloads/AirPollutionInGrenoble.pdf /home/nubudi/tests_export
#+END_SRC

#+RESULTS:

#+BEGIN_SRC shell :session *shell* :results output :exports both
git add --all
git commit -m "added a file"
git annex export master --to myremote
#+END_SRC

#+RESULTS:
: 
: [master 4b4fc7f] added a file
:  1 file changed, 0 insertions(+), 0 deletions(-)
:  create mode 100644 AirPollutionInGrenoble.pdf
: export myremote AirPollutionInGrenoble.pdf 
: 31.98 KiB         5 MiB/s                         ok
: (recording state in git...)

#+BEGIN_SRC shell :session *shell* :results output :exports both
git mv AirPollutionInGrenoble.pdf AirPollution.pdf
git commit -m "changed"
#+END_SRC

#+RESULTS:
: 
: [master 3ad0627] changed
:  1 file changed, 0 insertions(+), 0 deletions(-)
: AirPollution.pdf (100%)


#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex export master --to myremote
#+END_SRC

#+RESULTS:
: 
: .git-annex-tmp-content-SHA1--0295c5f5fdea625e2191b79eccf8e9b7020302dd ok
: AirPollution.pdf ok
: (recording state in git...)


- Now, on the other side, we can try to make changes in the remote and
  see if we can import them into the test repository. To do this, we
  can choose to add/edit something on the remote and then to use the
  command import to fetch the changes.

NB: this is a stupid mistake, i copied the file into the wrong
directory (the one that i use for tests and not the remote) so i just
ended up adding the file and exporting it. The actual test is down (*).
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/tests_export
mv /home/nubudi/Downloads/Essay.pdf .
ls
#+END_SRC

#+RESULTS:
: 
: (base) nubudi@ubunto:~/tests_export$ AirPollution.pdf  Essay.pdf  writing

#+BEGIN_SRC shell :session *shell* :results output :exports both
git add Essay.pdf
git commit -m "added a new file to the remote"
#+END_SRC

#+RESULTS:
: 
: [master 7267281] added a new file to the remote
:  1 file changed, 0 insertions(+), 0 deletions(-)
:  create mode 100644 Essay.pdf

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex export master --to myremote
#+END_SRC

#+RESULTS:
: export myremote Essay.pdf 
: 31.98 KiB        34 MiB/s                         ok
: (recording state in git...)

(*) Here starts the test of adding a file into the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/tests_export2
cp /home/nubudi/Downloads/marco.jpeg .
ls
#+END_SRC

#+RESULTS:
: 
: (base) nubudi@ubunto:~/tests_export2$ AirPollution.pdf  Essay.pdf  marco.jpeg  writing


#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex sync
#+END_SRC

#+RESULTS:
: commit 
: On branch master
: nothing to commit, working tree clean
: ok


#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex import master --from myremote
#+END_SRC

#+RESULTS:
#+begin_example
Invalid option `--from'

Usage: git-annex COMMAND
  git-annex - manage files with git, without checking their contents in
  
  Commonly used commands:
  
  add             PATH ...         add files to annex
  addurl          URL ...          add urls to annex
  assistant                        automatically sync changes
  copy            PATH ...         copy content of files to/from another repository
  drop            PATH ...         remove content of files from repository
  edit            PATH ...         same as unlock
  export          TREEISH          export content to a remote
  get             PATH ...         make content of annexed files available
  help            COMMAND          display help
  import          PATH ...         move and add files from outside git working copy
  importfeed      URL ...          import files from podcast feeds
  lock            PATH ...         undo unlock command
  mirror          PATH ...         mirror content of files to/from another repository
  move            PATH ...         move content of files to/from another repository
  multicast                        multicast file distribution
  rmurl           FILE URL ...     record file is not available at url
  status          PATH ...         show the working tree status
  sync            REMOTE ...       synchronize local repository with remotes
  undo            PATH ...         undo last change to a file or directory
  unlock          PATH ...         unlock files for modification
  watch                            watch for changes and autocommit
  webapp                           launch webapp
  
  Repository setup commands:
  
  adjust                           enter adjusted branch
  config                           configuration stored in git-annex branch
  dead            REMOTE ...       hide a lost repository or key
  describe        REMOTE DESC      change description of a repository
  direct                           switch repository to direct mode
  enable-tor      uid              enable tor hidden service
  enableremote    NAME K=V ...     enables git-annex to use a remote
  group           REMOTE DESC      add a repository to a group
  groupwanted     GROUP EXPR       get or set groupwanted expression
  indirect                         switch repository to indirect mode
  init            DESC             initialize git-annex
  initremote      NAME K=V ...     creates a special (non-git) remote
  numcopies       NUMBER           configure desired number of copies
  p2p                              configure peer-2-peer links between repositories
  required        REMOTE EXPR      get or set required content expression
  schedule        REMOTE EXPR      get or set scheduled jobs
  semitrust       REMOTE ...       return repository to default trust level
  trust           REMOTE ...       trust a repository
  ungroup         REMOTE DESC      remove a repository from a group
  untrust         REMOTE ...       do not trust a repository
  vicfg                            edit configuration in git-annex branch
  wanted          REMOTE EXPR      get or set preferred content expression
  
  Repository maintenance commands:
  
  addunused       NUM|RANGE ...    add back unused files
  dropunused      NUM|RANGE ...    drop unused file content
  expire          REMOTE:TIME ...  expire inactive repositories
  fix             PATH ...         fix up links to annexed content
  forget                           prune git-annex branch history
  fsck            PATH ...         find and fix problems
  merge                            automatically merge changes from remotes
  remotedaemon                     persistent communication with remotes
  repair                           recover broken git repository
  unused                           look for unused file content
  upgrade                          upgrade repository layout
  
  Query commands:
  
  find            PATH ...         lists available files
  info            ITEM ...         shows  information about the specified item or the repository as a whole
  inprogress      PATH ...         access files while they're being downloaded
  list            PATH ...         show which remotes contain files
  log             PATH ...         shows location log
  map                              generate map of repositories
  version                          show version info
  whereis         PATH ...         lists repositories that have file content
  
  Metadata commands:
  
  metadata        PATH ...         sets or gets metadata of a file
  vadd            FIELD=GLOB ...   add subdirs to current view
  vcycle                           switch view to next layout
  vfilter         FIELD=VALUE ...  filter current view
  view            FIELD=VALUE ...  enter a view branch
  vpop            NUMBER           switch back to previous view
  
  Utility commands:
  
  migrate         PATH ...         switch data to different backend
  reinit          UUID|DESC        initialize repository, reusing old UUID
  reinject        SRC DEST ...     inject content of file back into annex
  unannex         PATH ...         undo accidental add command
  uninit          PATH ...         de-initialize git-annex and clean out repository
  
  Plumbing commands:
  
  calckey         FILE ...         calculates the key that would be used to refer to a file
  checkpresentkey KEY REMOTE       check if key is present in remote
  contentlocation KEY ...          looks up content for a key
  diffdriver      -- cmd --        external git diff driver shim
  dropkey         KEY ...          drops annexed content for specified keys
  examinekey      KEY ...          prints information from a key
  findref         REF              lists files in a git ref
  fromkey         KEY PATH ...     adds a file using a specific key
  lookupkey       FILE ...         looks up key used for file
  matchexpression EXPR             checks if a preferred content expression matches
  post-receive                     run by git post-receive hook
  pre-commit      PATH ...         run by git pre-commit hook
  proxy           -- git command   safely bypass direct mode guard
  readpresentkey  KEY UUID         read records of where key is present
  registerurl     KEY URL          registers an url for a key
  rekey           PATH KEY ...     change keys used for files
  resolvemerge                     resolve merge conflicts
  setkey          KEY PATH         sets annexed content for a key
  setpresentkey   KEY UUID [1|0]   change records of where key is present
  smudge          FILE             git smudge filter
  transferkey     KEY              transfers a key from or to a remote
  transferkeys                     transfers keys
  
  Testing commands:
  
  fuzztest                         generates fuzz test files
  test                             run built-in test suite
  testremote      REMOTE           test transfers to/from a remote
#+end_example

** Importing a tree of files.
- Importing from a special remote  first  downloads  all  new  content
from  it,  and  then constructs  a git commit that reflects
files that have changed on the special remote since the last time git-annex looked at it. Merging that commit into your repository will update
it to reflect changes made on the special remote.
       
- To be able to import a tree of files from a special remote, we need to
configurate the remote when we first initalize it by using the option
importtree=yes (not all special remotes allow this but directory at
least is one of the ones that do).

- Tutorial to test import: we have already tested the work of git
  annex export and we saw that it works, now we will do the same
  tutorial, but this time, we will be allowing the directory remote to
  import trees as well.

  Let's create a folder where we will be working and doing all the
  next tests.



#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~
mkdir tests_export_import
cd tests_export_import
mkdir dir_remote
mkdir dir_test
#+END_SRC

#+RESULTS:

initiating the git and the git annex repository in the testing directory.
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd dir_test
git init
git annex init
#+END_SRC

#+RESULTS:
: 
: Initialized empty Git repository in /home/nubudi/tests_export_import/dir_test/.git/
: init  ok
: (recording state in git...)

adding a bunch of files to do the testing directory
#+BEGIN_SRC shell :session *shell* :results output :exports both
cp -R ~/Downloads/writing /home/nubudi/tests_export_import/dir_test
#+END_SRC

#+RESULTS:

now we can check the test directory to see that the the other
directory has been copied into it.
#+BEGIN_SRC shell :session *shell* :results output :exports both
ls
cd writing
ls
#+END_SRC

#+RESULTS:
: writing
: (base) nubudi@ubunto:~/tests_export_import/dir_test/writing$ drafts  essays  notes

#+BEGIN_SRC shell :session *shell* :results output :exports both
pwd
#+END_SRC

#+RESULTS:
: /home/nubudi/tests_export_import/dir_test/writing

Now, we can add the files to the repository and commit all the
changes.
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ..
git add --all
git commit -m "adding a directory containing a few folders and files into this git repository"
#+END_SRC

#+RESULTS:
: 
: (base) nubudi@ubunto:~/tests_export_import/dir_test$ [master (root-commit) 7aaca74] adding a directory containing a few folders and files into this git repository
:  5 files changed, 0 insertions(+), 0 deletions(-)
:  create mode 100644 writing/drafts/_Project Pain.pdf
:  create mode 100644 writing/drafts/the quest for mortality.pdf
:  create mode 100644 writing/essays/OumaimaHajji_5G.pdf
:  create mode 100644 writing/notes/Internship_Notes.pdf
:  create mode 100644 writing/notes/notes.pdf

Now, we can initialize the remote that we will be exporting the tree
of files to.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex initremote myremote type=directory directory=/home/nubudi/tests_export_import/dir_remote importtree=yes exporttree=yes encryption=none
#+END_SRC

#+RESULTS:
: initremote myremote ok
: (recording state in git...)

We export the master branch to the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex export master --to myremote
#+END_SRC

#+RESULTS:
#+begin_example
export myremote writing/drafts/_Project Pain.pdf 
31.98 KiB         6 MiB/s                         ok
export myremote writing/drafts/the quest for mortality.pdf 
31.98 KiB        12 MiB/s                         ok
export myremote writing/essays/OumaimaHajji_5G.pdf 
31.98 KiB        22 MiB/s                         ok
export myremote writing/notes/Internship_Notes.pdf 
31.98 KiB         1 MiB/s                         ok
export myremote writing/notes/notes.pdf 
31.98 KiB        12 MiB/s                         ok
(recording state in git...)
#+end_example

We can check to see if the tree has been exported to the remote.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ..
cd dir_remote
ls
cd writing
ls
#+END_SRC

#+RESULTS:
: 
: (base) nubudi@ubunto:~/tests_export_import/dir_remote$ writing
: (base) nubudi@ubunto:~/tests_export_import/dir_remote/writing$ drafts  essays  notes

Now, we can go back to the test repository and make changes.
#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/tests_export_import/dir_test
pwd
#+END_SRC

#+RESULTS:
: 
: /home/nubudi/tests_export_import/dir_test

#+BEGIN_SRC shell :session *shell* :results output :exports both
cp ~/Downloads/AirPollutionInGrenoble.pdf /home/nubudi/tests_export_import/dir_test
#+END_SRC

#+RESULTS:

We add the untracked file and commit the changes before exporting to
the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git add --all
git commit -m "added a file"
git annex export master --to myremote
#+END_SRC

#+RESULTS:
: 
: [master 3119727] added a file
:  1 file changed, 0 insertions(+), 0 deletions(-)
:  create mode 100644 AirPollutionInGrenoble.pdf
: export myremote AirPollutionInGrenoble.pdf 
: 31.98 KiB         5 MiB/s                         ok
: (recording state in git...)


Now, let's make changes in the remote. We can do this simply by adding
a new file or by changing the name of an existing file.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cp ~/Downloads/Essay.pdf /home/nubudi/tests_export_import/dir_remote
#+END_SRC

#+RESULTS:


#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/tests_export_import/dir_test
git status
git add --all
git commit -m "small changes to the file"
git annex export master --to myremote
#+END_SRC

#+RESULTS:
#+begin_example

On branch master
Changes to be committed:
..." to unstage)

	new file:   dir_remote/AirPollutionInGrenoble.pdf
	new file:   dir_remote/Essay.pdf
	new file:   dir_remote/writing/drafts/_Project Pain.pdf
	new file:   dir_remote/writing/drafts/the quest for mortality.pdf
	new file:   dir_remote/writing/essays/OumaimaHajji_5G.pdf
	new file:   dir_remote/writing/notes/Internship_Notes.pdf
	new file:   dir_remote/writing/notes/notes.pdf

Changes not staged for commit:
..." to update what will be committed)
..." to discard changes in working directory)

	deleted:    AirPollutionInGrenoble.pdf
	deleted:    dir_remote/AirPollutionInGrenoble.pdf
	deleted:    dir_remote/Essay.pdf
	deleted:    dir_remote/writing/drafts/_Project Pain.pdf
	deleted:    dir_remote/writing/drafts/the quest for mortality.pdf
	deleted:    dir_remote/writing/essays/OumaimaHajji_5G.pdf
	deleted:    dir_remote/writing/notes/Internship_Notes.pdf
	deleted:    dir_remote/writing/notes/notes.pdf

Untracked files:
..." to include in what will be committed)

	AirPollutionGrenoble.pdf
(base) nubudi@ubunto:~/tests_export_import/dir_test$ [master 9887489] small changes to the file
 1 file changed, 0 insertions(+), 0 deletions(-)
AirPollutionGrenoble.pdf (100%)
rename myremote AirPollutionInGrenoble.pdf -> .git-annex-tmp-content-SHA1--0295c5f5fdea625e2191b79eccf8e9b7020302dd 
  rename failed; deleting instead
ok
export myremote AirPollutionGrenoble.pdf 
31.98 KiB         3 MiB/s                         ok
(recording state in git...)
#+end_example

Now, let's make changes in the remote. We can do this simply by adding
a new file or by changing the name of an existing file.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cp ~/Downloads/Essay.pdf /home/nubudi/tests_export_import/dir_remote
#+END_SRC

#+RESULTS:


#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/tests_export_import
mkdir dir_import
cd dir_import
git init
git annex init
#+END_SRC

#+RESULTS:
: 
: mkdir: cannot create directory ‘dir_import’: File exists
: (base) nubudi@ubunto:~/tests_export_import/dir_import$ Initialized empty Git repository in /home/nubudi/tests_export_import/dir_import/.git/
: init  ok
: (recording state in git...)


Here, we try to import from a directory and not from a special
directory remote. By doing executing this command, git annex import
moves files from somewhere outside the git working copy, and adds them
to the annex. In contrast to importing from a special directory
remote, imported files are deleted from the given path.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex import /home/nubudi/tests_export_import/dir_remote
#+END_SRC

#+RESULTS:
: import dir_remote/Essay.pdf ok
: import dir_remote/AirPollutionGrenoble.pdf ok
: (recording state in git...)

** Importing/Exporting to/from a special remote.
'You can combine using git annex import to fetch changes from a
special remote with git annex export to send your local changes to the
special remote. You can only import from special remotes that were
configured with importtree=yes when set up with
git-annex-initremote(1). Only some kinds of special remotes will let
you configure them this way.'
Another way to import from special remotes is using the git annex sync
--content command (and the git-annex assistant). It can also be used to
import from a special remote. To do this, you need to configure
"remote..annex-tracking-branch" to tell it what branch to track.

#+begin_example
git config remote.myremote.annex-tracking-branch master
git annex sync --content
#+end_example

We can choose whether or not we want to import the content of the
files or just the metadata (--content or --no-content). Even if we
don't download the content, the keys are generated from information
provided by the special remote. 


links:
https://git-annex.branchable.com/git-annex-import/
https://git-annex.branchable.com/git-annex-export/


- look into the encryption.


* Wednesday 16/06.
** encryption types.
git-annex mostly does not use encryption. Anyone with access to a git
repository can see all the filenames in it, its history, and can
access any annexed file contents. It's mainly used when sending files
to untrusted special remotes.
Such an encrypted remote uses strong (symmetric or asymmetric)
encryption on the contents of files, as well as HMAC hashing of the
filenames. The size of the encrypted files, and access patterns of the
data, should be the only clues to what is stored in such a remote.

- hybrid encryption: The hybrid key design allows additional
  encryption keys to be added on to a special remote later. Due to
  this flexibility, it is the default and recommended encryption
  scheme. To add a new key and allow it to access all the content that
  is stored in the encrypted special remote, just run git annex
  enableremote specifying the keyid to add:
#+begin_example
  git annex enableremote myremote keyid+=788A3F4C
#+end_example
  While a key can later be removed from the list, note that it will
  not prevent the owner of the key from accessing data on the remote
  (which is by design impossible to prevent, short of deleting the
  remote). In fact the only sound use of keyid-= is probably to
  replace a revoked key.

- shares encryption: Alternatively, you can configure git-annex to use
  a shared cipher to encrypt data stored in a remote. This shared
  cipher is stored, unencrypted in the git repository. So it's shared
  among every clone of the git repository.
  The advantage is you don't need to set up gpg keys. The disadvantage
  is that this is insecure unless you trust every clone of the git
  repository with access to the encrypted data stored in the special
  remote.

- regular public encryption: This alternative simply encrypts the
  files in the special remotes to one or more public keys. The
  corresponding private key is needed to store anything in the remote,
  or access anything stored in it.
  A disadvantage is that it is not easy to later add additional public
  keys to the special remote. While the enableremote parameters
  keyid+= and keyid-= can be used, they have no effect on encrypted
  files that are already stored in the remote.
  But even in this case, since the files are not re-encrypted, the
  revoked key has to be kept around to be able to decrypt those
  files. (Of course, if the reason for revocation is that the key has
  been compromised, it is insecure to leave files encrypted using that
  old key, and the user should re-encrypt everything.)

- regular public encryption with shared filename encryption: This is a
  variation on encryption=pubkey which lets anyone who has access to
  the gpg public keys store files in the special remote. But, only
  owners of the corresponding gpg private keys can retrieve the files
  from the special remote.
  This might be useful if you want to let others drop off files for
  you in a special remote, so that only you can access them.
  The filenames used on the special remote are encrypted using HMAC,
  which prevents the special remote from seeing the filenames. But,
  anyone who can clone the git repository can access the HMAC cipher;
  it's stored unencrypted in the git repository.
  


link: https://git-annex.branchable.com/encryption/

** downloads from special remotes.

#+begin_example
annex.security.allow-unverified-downloads
#+end_example

For security reasons, git-annex refuses to download content from most
special remotes when it cannot check a hash to verify that the correct
content was downloaded. This particularly impacts downloading the
content of URL or WORM keys, which lack hashes.

The best way to avoid problems due to this is to migrate files away
from such keys, before their content reaches a special remote. See
git-annex-migrate(1).

When the content is only available from a special remote, you can use
this configuration to force git-annex to download it. But you do so at
your own risk, and it's very important you read and understand the
information below first!

Downloading unverified content from encrypted special remotes is
prevented, because the special remote could send some other encrypted
content than what you expect, causing git-annex to decrypt data that
you never checked into git-annex, and risking exposing the decrypted
data to any non-encrypted remotes you send content to.

Downloading unverified content from (non-encrypted) external special
remotes is prevented, because they could follow http redirects to web
servers on localhost or on a private network, or in some cases to a
file:/// url.

If you decide to bypass this security check, the best thing to do is
to only set it temporarily while running the command that gets the
file. The value to set the config to is "ACKTHPPT". For example:

git -c annex.security.allow-unverified-downloads=ACKTHPPT annex get
myfile.

It would be a good idea to check that it downloaded the file you
expected, too.

- Per-remote configuration of
  annex.security.allow-unverified-downloads:  
#+begin_example
remote.<name>.annex-security-allow-unverified-downloads
#+end_example


* Thursday 17/06.
** Testing the changes of git-annex-remote-zenodo.
*** Preparation.
#+BEGIN_SRC shell :session *shell* :results output :exports both
pwd
cd ~/Desktop
#+END_SRC

#+RESULTS:
: /home/nubudi/Desktop/Internship

First, we need to export the path to where the git-annex-remote-zenodo
function so as to be able to locate it when executing.
#+BEGIN_SRC shell :session *shell* :results output :exports both
export PATH=$PATH:/home/nubudi/Desktop/test_remote
#+END_SRC

#+RESULTS:

Let's check if the path has been successfully exported:
#+BEGIN_SRC shell :session *shell* :results output :exports both
echo $PATH
#+END_SRC

#+RESULTS:
: /home/nubudi/anaconda2/bin:/home/nubudi/anaconda2/condabin:/home/nubudi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/nubudi/Desktop/test_remote

We also need to make the program executable. To do this, we can simply
change the permissions in the properties of the program (by checking
the box) or we can do it using the shell command line with ths
command (go to the path where the program is to execute it):

#+BEGIN_SRC shell :session *shell* :results output :exports both
chmod +x git-annex-remote-zenodo
#+END_SRC
You'll need the sheebang line #!/usr/bin/env python3 to execute this
command which we added to the program.

Now, we can simply work with git annex like we would usually do. If we
are working in a new repository, we will have to initialize git and
git annex before the next steps. In this case, I'm working in an
already initialized repository. We also need to initialize a special
remote using the command with added options (ex: url to specify if we
want to use the sandbox or newversion if we want to initialize the
remote as a new version of an already published remote)

#+begin_example
git annex initremote test-zenodo type=external externaltype=zenodo key=ACCESS_TOKEN  encryption=
#+end_example

In this case, I'm reusing a remote that I've already initialized. To
use an already initialized remote in another directory, we can use the
command enableremote. We can also specify other options when doing so
if needed.

#+begin_example
git annex enableremote test-zenodo
#+end_example

*** Uploading a file to the remote.
As we can see below, the file test/notes.org is annexed and stored in
two places, here and in a remote called 'extra'. It still hasn't been
uploaded to the zenodo remote. 
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
: here
: |extra
: ||web
: |||bittorrent
: ||||test-zenodo
: |||||
: XX___ test/notes.org

Now we can finally upload a file into the zenodo remote. This git-annex
command uses some of the functions we have implemente in the remote
(checkpresent to see if the exact same file is already uploaded and
transferstore which uploads the file).
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex copy test/notes.org --to test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
copy test/notes.org finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
[]
(to test-zenodo...) 
finished the put operation. Here is the returned message 

200
finished exporting the file... 

ok
#+end_example

We can see at the end of the return message that git has recorded the
state and so we now we can check where the file is to make sure that
it's been uploaded to the remote. As we can see below, there is now an
added X to mark the presence of the file in the remote as well.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
: here
: |extra
: ||web
: |||bittorrent
: ||||test-zenodo
: |||||
: XX__X test/notes.org

We can also take a look at the remote and the list of the files that
have been uploaded to the deposit to see if the uploaded file has been
exported using the key as a filename. we can check this manually by
going to the depositions url and looking at the filename in the
deposit.
Or, we can check this by also getting the name of the file in the
remote and comparing it to the key used by git-annex to refer to the
file.

+ Getting the filename from the remote:
#+begin_src python :results output :exports both
import requests
import json
r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/866268/files', params={'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG' })
print(json.dumps(r.json(), indent=4))
#+end_src

#+RESULTS:
#+begin_example
[
    {
        "checksum": "a31ab3d02693c566fbffccda5955b384",
        "filename": "SHA256E-s33173--0aeb5832762f16a00438b5718137c9c61db03628c2ac02f163afb41ac46b5470.org",
        "filesize": 33173,
        "id": "3ba257d9-5749-4366-8ad3-e9dc4b576555",
        "links": {
            "download": "https://sandbox.zenodo.org/api/files/c213200e-691a-4b60-8288-6ea69aaca0e7/SHA256E-s33173--0aeb5832762f16a00438b5718137c9c61db03628c2ac02f163afb41ac46b5470.org",
            "self": "https://sandbox.zenodo.org/api/deposit/depositions/866268/files/3ba257d9-5749-4366-8ad3-e9dc4b576555"
        }
    }
]
#+end_example

+ Getting the key of the file using the info command:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex info test/notes.org
#+END_SRC

#+RESULTS:
: file: test/notes.org
: size: 33.17 kilobytes
: key: SHA256E-s33173--0aeb5832762f16a00438b5718137c9c61db03628c2ac02f163afb41ac46b5470.org
: present: true


As we can see, it's the same key.

*** Getting the file from the remote .
Now, can try to get the file from the zenodo remote. Before doing
this, we will drop it from where it's being stored locally so as to be
able to retrieve it from the remote.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop test/notes.org
#+END_SRC

#+RESULTS:
: drop test/notes.org ok
: (recording state in git...)

We can check to see where the file is kept now. As we can see, it's
being stored in the 'extra' remote and in the zenodo remote where we
have just uploaded it.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
: here
: |extra
: ||web
: |||bittorrent
: ||||test-zenodo
: |||||
: _X__X test/notes.org

It's no longer available locally, but we can get it from the remote
using the get command. We can see in the results that the file has
been successfully retrieved.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex get test/notes.org --from test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
get test/notes.org (from test-zenodo...) 
finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
(checksum...) ok
(recording state in git...)
#+end_example

Let's check the where abouts of the file again to see if it's here
locally.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex whereis test/notes.org
git annex list
#+END_SRC

#+RESULTS:
#+begin_example
whereis test/notes.org finished the get operation. Here is the returned message 

200
(3 copies) 
  	20111730-b84c-46f1-8019-4e8c53e2880b -- remote zenodo [here]
   	4728ae64-ffad-4f66-8e95-0e8bf4293bba -- [test-zenodo]
   	b6b0cd5b-0259-43c0-a1c1-6531dd07b707 -- a directory where extra stuff is kept [extra]
ok
here
|extra
||web
|||bittorrent
||||test-zenodo
|||||
XX__X test/notes.org
#+end_example

*** Dropping the file from the remote.
We can now try to remove the file from the zenodo remote where it's
being stored. Since we already have two copies of the file, this can
be done without the fear of losing it.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop test/notes.org --from test-zenodo
#+END_SRC

#+RESULTS:
: drop test-zenodo test/notes.org finished the get operation. Here is the returned message 
: 
: 200
: finished the get operation. Here is the returned message 
: 
: 200
: ok

The file has been successfully dropped from the remote and we can
check that using these commands:

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex whereis test/notes.org
git annex list
#+END_SRC

#+RESULTS:
#+begin_example
whereis test/notes.org (2 copies) 
  	20111730-b84c-46f1-8019-4e8c53e2880b -- remote zenodo [here]
   	b6b0cd5b-0259-43c0-a1c1-6531dd07b707 -- a directory where extra stuff is kept [extra]
ok
here
|extra
||web
|||bittorrent
||||test-zenodo
|||||
XX___ test/notes.org
#+end_example

*** Moving a file from / to the remote.
When we move a file from a remote to another or locally it's as if we
made two operations: copying it to X and dropping it from Y. So it's
useful to do this when we already keep track of where all the copies
of a file is and we just want to move it around without having to drop
it everytime.

Here, we can see that it's in the zenodo remote a well as here locally.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex whereis test/notes.org
#+END_SRC

#+RESULTS:
: whereis test/notes.org finished the get operation. Here is the returned message 
: 
: 200
: (3 copies) 
:   	20111730-b84c-46f1-8019-4e8c53e2880b -- remote zenodo [here]
:    	4728ae64-ffad-4f66-8e95-0e8bf4293bba -- [test-zenodo]
:    	b6b0cd5b-0259-43c0-a1c1-6531dd07b707 -- a directory where extra stuff is kept [extra]
: ok


let's drop it in the remote and then move the copu we have here to the
remote to see what will change.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop test/notes.org --from test-zenodo
#+END_SRC

#+RESULTS:
: drop test-zenodo test/notes.org finished the get operation. Here is the returned message 
: 
: 200
: finished the get operation. Here is the returned message 
: 
: 200
: ok
: (recording state in git...)

Checking again the whereabouts of the file:

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list 
#+END_SRC

#+RESULTS:
: here
: |extra
: ||web
: |||bittorrent
: ||||test-zenodo
: |||||
: XX___ test/notes.org

Now, let's move it from here locally to the zenodo remote.

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex move test/notes.org --to test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
move test/notes.org finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
[]
(to test-zenodo...) 
finished the put operation. Here is the returned message 

200
finished exporting the file... 

ok
(recording state in git...)
#+end_example


Let's check the whereabouts of the file again:

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list 
#+END_SRC

#+RESULTS:
: here
: |extra
: ||web
: |||bittorrent
: ||||test-zenodo
: |||||
: _X__X test/notes.org

As we can see, it's no longer available locally but it's accessible in
the remote.

** Testing the uploads with different types of encryptions.
*** intro.
I've added some files to be annexed so as to use them if needed in the
following tests.

#+BEGIN_SRC shell :session *shell* :results output :exports both
cd ~/Desktop
git annex list
#+END_SRC

#+RESULTS:
#+begin_example

here
|web
||bittorrent
|||test-zenodo
||||
___X test/notes.org
X___ writing/Outline.odt
X___ writing/Outline.pdf
X___ writing/aminux.txt
X___ writing/the_deceitful_truth.odt
X___ writing/the_quest_for_mortality.odt
#+end_example

First, we need to export the path to where the git-annex-remote-zenodo
function so as to be able to locate it when executing.
#+BEGIN_SRC shell :session *shell* :results output :exports both
export PATH=$PATH:/home/nubudi/Desktop/test_remote
#+END_SRC

#+RESULTS:

Let's check if the path has been successfully exported:
#+BEGIN_SRC shell :session *shell* :results output :exports both
echo $PATH
#+END_SRC

#+RESULTS:
: /home/nubudi/anaconda2/bin:/home/nubudi/anaconda2/condabin:/home/nubudi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/nubudi/Desktop/test_remote

*** hybrid encryption.
We first need to create a gpg key to be able to use this type of
encryption. After doing so, we can enable an existing remote or create
a new one with initremote. 
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex enableremote test-zenodo encryption=hybrid keyid=69E2FB9A11D14CB3CB3A12BCCD7D01BA0347F528
#+END_SRC

#+RESULTS:
: enableremote test-zenodo (encryption setup) (to gpg keys: CD7D01BA0347F528) finished the post operation. Here is the returned message 
: 
: 201
: ok
: (recording state in git...)

We can see by executing this command that the type of encryption in
the configuration is stated as hybrid.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex info test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
remote: test-zenodo
description: [test-zenodo]
uuid: 4728ae64-ffad-4f66-8e95-0e8bf4293bba
trust: semitrusted
cost: 250.0
type: external
externaltype: zenodo
encryption: hybrid (to gpg keys: CD7D01BA0347F528)
chunking: none
remote annex keys: 1
remote annex size: 33.17 kilobytes
#+end_example

Now, we can copy an annexed file into the remote. Because we are now
using the hybrid encryption, we will need to give our password when we
want to communicate with the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex copy writing/the_deceitful_truth.odt --to test-zenodo 
#+END_SRC

#+RESULTS:
#+begin_example
copy writing/the_deceitful_truth.odt finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
[]
(to test-zenodo...) 
finished the put operation. Here is the returned message 

200
finished exporting the file... 

ok
(recording state in git...)
#+end_example

!! When uploaded, the file's name became: GPGHMAC<key> as can be seen
   below:
#+begin_src python :results output :exports both
import requests
import json
r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/866481/files', params={'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG' })
print(json.dumps(r.json(), indent=4))
#+end_src

#+RESULTS:
#+begin_example
[
    {
        "checksum": "5fa5147e4c15b41ce590548972fb4c54",
        "filename": "GPGHMACSHA1--f281097ad56fe6bd30e6445d178efec6799745cb",
        "filesize": 47652,
        "id": "98f0edea-33b3-4c4f-8aa7-35fd1259d6c2",
        "links": {
            "download": "https://sandbox.zenodo.org/api/files/407c82d1-124d-4053-8843-c9b7195270a8/GPGHMACSHA1--f281097ad56fe6bd30e6445d178efec6799745cb",
            "self": "https://sandbox.zenodo.org/api/deposit/depositions/866481/files/98f0edea-33b3-4c4f-8aa7-35fd1259d6c2"
        }
    }
]
#+end_example

+ MAC algo: The default MAC algorithm to be applied on the filenames is
HMACSHA1. A stronger one, for instance HMACSHA512, can be chosen upon
creation of the special remote with the option mac=HMACSHA512. The
available MAC algorithms are HMACSHA1, HMACSHA224, HMACSHA256,
HMACSHA384, and HMACSHA512. Note that it is not possible to change
algorithm for a non-empty remote.


Displaying information about this file:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex info writing/the_deceitful_truth.odt 
#+END_SRC

#+RESULTS:
: file: writing/the_deceitful_truth.odt
: size: 48.88 kilobytes
: key: SHA256E-s48875--97ac6f560a81ef7509b0278407dc39348e42f29b20d12a4bc2f443f5eea95ed9.odt
: present: true

Now, let's drop it locally and then try to get it back.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop writing/the_deceitful_truth.odt 
#+END_SRC

#+RESULTS:
#+begin_example
drop writing/the_deceitful_truth.odt finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
[{u'id': u'98f0edea-33b3-4c4f-8aa7-35fd1259d6c2', u'checksum': u'5fa5147e4c15b41ce590548972fb4c54', u'filesize': 47652, u'links': {u'download': u'https://sandbox.zenodo.org/api/files/407c82d1-124d-4053-8843-c9b7195270a8/GPGHMACSHA1--f281097ad56fe6bd30e6445d178efec6799745cb', u'self': u'https://sandbox.zenodo.org/api/deposit/depositions/866481/files/98f0edea-33b3-4c4f-8aa7-35fd1259d6c2'}, u'filename': u'GPGHMACSHA1--f281097ad56fe6bd30e6445d178efec6799745cb'}]
Yes, this file exists in the remote: GPGHMACSHA1--f281097ad56fe6bd30e6445d178efec6799745cb
ok
(recording state in git...)
#+end_example

It's no longer here as we can see.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||test-zenodo
||||
___X test/notes.org
X___ writing/Outline.odt
X___ writing/Outline.pdf
X___ writing/aminux.txt
___X writing/the_deceitful_truth.odt
X___ writing/the_quest_for_mortality.odt
#+end_example

Now, let's get it back from the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex get writing/the_deceitful_truth.odt --from test-zenodo 
#+END_SRC

#+RESULTS:
#+begin_example
get writing/the_deceitful_truth.odt (from test-zenodo...) 
finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
(checksum...) ok
(recording state in git...)
#+end_example

Displaying information about this file:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex info writing/the_deceitful_truth.odt 
#+END_SRC

#+RESULTS:
: file: writing/the_deceitful_truth.odt
: size: 48.88 kilobytes
: key: SHA256E-s48875--97ac6f560a81ef7509b0278407dc39348e42f29b20d12a4bc2f443f5eea95ed9.odt
: present: true

*** shared encryption.
We can create a new remote with initremote and specify in the options
that the type of encryption we want is shared encryption. This uses a
shared cipher which is stored, unencrypted, in the git repository. So,
every clone of this repository can access is.
This is not secure unless you trust every clone of the git
repository. 
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex initremote new-test-zenodo encryption=shared type=external externaltype=zenodo exporttree=yes importtree=yes
#+END_SRC

#+RESULTS:
: initremote new-test-zenodo git-annex: cannot enable both encryption and exporttree

Retrying without enabling exporttree and importtree:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex initremote new-test-zenodo encryption=shared type=external externaltype=zenodo key=K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG
#+END_SRC

#+RESULTS:
: initremote new-test-zenodo (encryption setup) (encryption key stored in git repository) finished the post operation. Here is the returned message 
: 
: 201
: ok
: (recording state in git...)

We can see by executing this command that the type of encryption in
the configuration is stated as shared.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex info new-test-zenodo
#+END_SRC

#+RESULTS:
#+begin_example
remote: new-test-zenodo
description: [new-test-zenodo]
uuid: a3fb3036-b5b8-4bed-b684-983942dc602e
trust: semitrusted
cost: 250.0
type: external
externaltype: zenodo
encryption: shared (encryption key stored in git repository)
chunking: none
remote annex keys: 0
remote annex size: 0 bytes
#+end_example

Now, we can copy an annexed file into the remote. 
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex copy writing/the_deceitful_truth.odt --to new-test-zenodo 
#+END_SRC

#+RESULTS:
#+begin_example
copy writing/the_deceitful_truth.odt finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
[]
(to new-test-zenodo...) 
finished the put operation. Here is the returned message 

200
finished exporting the file... 

ok
(recording state in git...)
#+end_example

Displaying information about this file:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex info writing/the_deceitful_truth.odt 
#+END_SRC

#+RESULTS:
: file: writing/the_deceitful_truth.odt
: size: 48.88 kilobytes
: key: SHA256E-s48875--97ac6f560a81ef7509b0278407dc39348e42f29b20d12a4bc2f443f5eea95ed9.odt
: present: true

#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex whereis writing/the_deceitful_truth.odt 
#+END_SRC

#+RESULTS:
: whereis writing/the_deceitful_truth.odt (3 copies) 
:   	20111730-b84c-46f1-8019-4e8c53e2880b -- remote zenodo [here]
:    	4728ae64-ffad-4f66-8e95-0e8bf4293bba -- [test-zenodo]
:    	a3fb3036-b5b8-4bed-b684-983942dc602e -- [new-test-zenodo]
: ok

Now, let's drop it locally and then try to get it back.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex drop writing/the_deceitful_truth.odt 
#+END_SRC

#+RESULTS:
#+begin_example
drop writing/the_deceitful_truth.odt finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
[{u'id': u'a3e4d856-7500-4e23-b5e7-2c5b89532059', u'checksum': u'7bf33ffde758357bbc502a00217b2285', u'filesize': 47652, u'links': {u'download': u'https://sandbox.zenodo.org/api/files/406520ff-2af3-4989-a50b-bee63a4fa2bd/GPGHMACSHA1--220f327281256e704e7987589cf1625abb15f4db', u'self': u'https://sandbox.zenodo.org/api/deposit/depositions/866525/files/a3e4d856-7500-4e23-b5e7-2c5b89532059'}, u'filename': u'GPGHMACSHA1--220f327281256e704e7987589cf1625abb15f4db'}]
Yes, this file exists in the remote: GPGHMACSHA1--220f327281256e704e7987589cf1625abb15f4db
ok
(recording state in git...)
#+end_example

It's no longer here as we can see.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex list
#+END_SRC

#+RESULTS:
#+begin_example
here
|web
||bittorrent
|||new-test-zenodo
||||test-zenodo
|||||
____X test/notes.org
X____ writing/Outline.odt
X____ writing/Outline.pdf
X____ writing/aminux.txt
___XX writing/the_deceitful_truth.odt
X____ writing/the_quest_for_mortality.odt
#+end_example

Now, let's get it back from the remote.
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex get writing/the_deceitful_truth.odt --from new-test-zenodo 
#+END_SRC

#+RESULTS:
#+begin_example
get writing/the_deceitful_truth.odt (from new-test-zenodo...) 
finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
finished the get operation. Here is the returned message 

200
(checksum...) ok
(recording state in git...)
#+end_example

Displaying information about this file:
#+BEGIN_SRC shell :session *shell* :results output :exports both
git annex info writing/the_deceitful_truth.odt 
#+END_SRC

#+RESULTS:
: file: writing/the_deceitful_truth.odt
: size: 48.88 kilobytes
: key: SHA256E-s48875--97ac6f560a81ef7509b0278407dc39348e42f29b20d12a4bc2f443f5eea95ed9.odt
: present: true

*** Notes taken during the meeting.
+ disableremote: publish + transforms the remote into aweb remote +
  disable the remote locally (git rm ) + need to take care of
  uploading an archive of the files to zendo before publishing the
  other deposit and keeps track of the files that have been copied
  (not annexed just in a simple zenodo deposit).

+ possible steps for the script:
  download the tar
  untar
  git init
  git annex init
  git annex add url (for each of the files to get their positions).
  !!! look into this!
  (also maybe does the same for all the remote web url files and find where they all are) 

+ Look into: test: addurl - registerurl (with the key)

+ encryption:
  - test encryting: with another remote (ex: directory/ amazon / google drive).
 
+ publish: git-annex-disableremote (with options)
  - look before to see if the user has already submitted some metadata
    to zenodo.
  - create a json file as a template (add options in comments to specify
    their use in case they are needed) -> (opt --json)
    else get the info from zenodo and then ask the user if the info is
    ok or change it accordingly.

+ initremote: when we create a new version of a record with enableremote (after
  disbaing it) we have to inform git-annex that the files that have
  been uploaded to the old deposit are now available on the new
  deposit (need to keep a link between the objects in git-annex and
  the files)


* Friday 18/06.
** encryption design.
*** encryption key management.
Data is encrypted by GnuPG using a symmetric cipher that is generated
by GnuPG when the special remote is created. (A symmetric
cipher is one that uses the same key for encryption and
decryption. Ciphers or algorithms can be either symmetric or
asymmetric. Symmetric ones use the same key (called a secret key or
private key) for transforming the original message, called plaintext,
into ciphertext and vice versa.) A symmetric cipher is one that uses
the same key for encryption and decryption. Ciphers or algorithms can
be either symmetric or asymmetric. Symmetric ones use the same key
(called a secret key or private key) for transforming the original
message, called plaintext, into ciphertext and vice versa. This scheme
allows new OpenPGP private keys to be given access to content that has
already been stored in the remote. 

Different encrypted remotes need to be able to each use different
ciphers. Allowing multiple ciphers to be used within a single remote
would add a lot of complexity, so is not supported. Instead, if you
want a new cipher, create a new S3 bucket, or whatever. There does not
seem to be much benefit to using the same cipher for two different
encrypted remotes.

So, the encrypted cipher is just stored with the rest of a remote's
configuration in remote.log: The file format is one line per remote,
starting with the uuid of the remote, followed by a space, and then a
series of var=value pairs, each separated by whitespace, and finally a
timestamp. Encrypted special remotes store their encryption key here,
in the "cipher" value. It is base64 encoded, and unless shared
encryption is used, is encrypted to one or more gpg keys. The first
256 bytes of the cipher is used as the HMAC SHA1 encryption key, to
encrypt filenames stored on the special remote. The remainder of the
cipher is used as a gpg symmetric encryption key, to encrypt the
content of files stored on the special remote. 

When git annex intiremote makes a remote, it generates a random
symmetric cipher, and encrypt it with the specified gpg key. To allow
another gpg public key access, update the encrypted cipher to be
encrypted to both gpg keys.

Note that there's a shared encryption mode where the cipher is not
encrypted. When this mode is used, any clone of the git repository can
decrypt files stored in its special remote.

*** filename enumeration.
The files stored in the remote should be encrypted. But, it needs to
be a repeatable encryption, so they cannot just be gpg encrypted, that
would yeild a new name each time. Instead, HMAC is used. Any hash
could be used with HMAC. SHA-1 is the default, but other hashes can be
chosen for new remotes.

For instance, the command fsck should be able to, for each file in the
repository, contact the encrypted remote to check if it has the
file. This can be done without enumeration, although it will mean
running gpg once per file fscked, to get the encrypted filename. 

*** other use of symmetric cipher.
The symmetric cipher can be used to encrypt other content than the
content sent to the remote. In particular, it may make sense to
encrypt whatever access keys are used by the special remote with the
cipher, and store that in remote.log. This way anyone whose gpg key
has been given access to the cipher can get access to whatever other
credentials are needed to use the special remote.
*** risks.
A risk of this scheme is that, once the symmetric cipher has been
obtained, it allows full access to all the encrypted content. Indeed
anyone owning a key that used to be granted access could already have
decrypted the cipher and stored a copy. While it is in possible to
remove a key with keyid-=, it is designed for a completely different
purpose and does not actually revoke access.

If git-annex stores the decrypted symmetric cipher in memory, then
there is a risk that it could be intercepted from there by an
attacker. Gpg ameliorates these type of risks by using locked
memory. For git-annex, note that an attacker with local machine access
can tell at least all the filenames and metadata of files stored in
the encrypted remote anyway, and can access whatever content is stored
locally. 
*** links.
https://git-annex.branchable.com/design/encryption/
https://git-annex.branchable.com/encryption/

** testing the different types of encryption in a remote.
*** hybrid.
a
** editing the metadata of a published record.
Let's try to change some of the metadata of a record that's already
been published. To do so, we first need to send a post request to the
API with the edit action so as to unlock it. Then, we can send a put
request containing the new data that we want to change to. When this
is over, we need to either discard the changes or publish the
record. If we don't do either of these actions, the deposit will stay
in a drafting state.
#+begin_src python :results output :exports both
import requests
import json
ACCESS_TOKEN= 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'
# r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/discard', params={'access_token': ACCESS_TOKEN})

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/edit', params={'access_token': ACCESS_TOKEN})
print(json.dumps(r.json(), indent=4))

# now making modifications

data = {
    "metadata": {
        "title": "A report about air pollution in Grenoble",
        "upload_type": "poster",
        "description": "report written by two students",
        "creators": [
            {"name": "H, O", "affiliation": "St"},
            {"name": "C, M", "affiliation": "St"}
        ]
    }
}

headers = {"Content-Type": "application/json"}

url = 'https://sandbox.zenodo.org/api/deposit/depositions/846331'
r = requests.put(url, data=json.dumps(data), headers=headers, params= {'access_token': ACCESS_TOKEN})
print(json.dumps(r.json(), indent=4))

#+end_src

#+RESULTS:
#+begin_example
{
    "conceptdoi": "10.5072/zenodo.846330",
    "conceptrecid": "846330",
    "created": "2021-06-02T13:12:08.831740+00:00",
    "doi": "10.5072/zenodo.846331",
    "doi_url": "https://doi.org/10.5072/zenodo.846331",
    "files": [
        {
            "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
            "filename": "AirPollutionInGrenoble.pdf",
            "filesize": 1107977,
            "id": "8b14ada3-07a2-4da4-a0af-6c18ce58ced4",
            "links": {
                "download": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca/AirPollutionInGrenoble.pdf",
                "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files/8b14ada3-07a2-4da4-a0af-6c18ce58ced4"
            }
        }
    ],
    "id": 846331,
    "links": {
        "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846331.svg",
        "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
        "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846330.svg",
        "conceptdoi": "https://doi.org/10.5072/zenodo.846330",
        "doi": "https://doi.org/10.5072/zenodo.846331",
        "latest": "https://sandbox.zenodo.org/api/records/846331",
        "latest_html": "https://sandbox.zenodo.org/record/846331",
        "record": "https://sandbox.zenodo.org/api/records/846331",
        "record_html": "https://sandbox.zenodo.org/record/846331"
    },
    "metadata": {
        "access_right": "open",
        "communities": [
            {
                "identifier": "zenodo"
            }
        ],
        "creators": [
            {
                "affiliation": "Student",
                "name": "H, O"
            },
            {
                "affiliation": "Student",
                "name": "M, C"
            }
        ],
        "description": "<p>first upload: a report written by students</p>",
        "doi": "10.5072/zenodo.846331",
        "license": "CC-BY-4.0",
        "prereserve_doi": {
            "doi": "10.5072/zenodo.846331",
            "recid": 846331
        },
        "publication_date": "2021-06-02",
        "title": "Air pollution in Grenoble - A report",
        "upload_type": "poster"
    },
    "modified": "2021-06-18T09:47:32.907609+00:00",
    "owner": 75563,
    "record_id": 846331,
    "state": "inprogress",
    "submitted": true,
    "title": "Air pollution in Grenoble - A report"
}
{
    "conceptdoi": "10.5072/zenodo.846330",
    "conceptrecid": "846330",
    "created": "2021-06-02T13:12:08.831740+00:00",
    "doi": "10.5072/zenodo.846331",
    "doi_url": "https://doi.org/10.5072/zenodo.846331",
    "files": [
        {
            "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
            "filename": "AirPollutionInGrenoble.pdf",
            "filesize": 1107977,
            "id": "8b14ada3-07a2-4da4-a0af-6c18ce58ced4",
            "links": {
                "download": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca/AirPollutionInGrenoble.pdf",
                "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files/8b14ada3-07a2-4da4-a0af-6c18ce58ced4"
            }
        }
    ],
    "id": 846331,
    "links": {
        "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846331.svg",
        "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
        "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846330.svg",
        "conceptdoi": "https://doi.org/10.5072/zenodo.846330",
        "discard": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/discard",
        "doi": "https://doi.org/10.5072/zenodo.846331",
        "edit": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/edit",
        "files": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files",
        "html": "https://sandbox.zenodo.org/deposit/846331",
        "latest": "https://sandbox.zenodo.org/api/records/846331",
        "latest_html": "https://sandbox.zenodo.org/record/846331",
        "newversion": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/newversion",
        "publish": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/publish",
        "record": "https://sandbox.zenodo.org/api/records/846331",
        "record_html": "https://sandbox.zenodo.org/record/846331",
        "registerconceptdoi": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/registerconceptdoi",
        "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331"
    },
    "metadata": {
        "access_right": "open",
        "creators": [
            {
                "affiliation": "St",
                "name": "H, O"
            },
            {
                "affiliation": "St",
                "name": "C, M"
            }
        ],
        "description": "report written by two students",
        "doi": "10.5072/zenodo.846331",
        "license": "CC-BY-4.0",
        "prereserve_doi": {
            "doi": "10.5072/zenodo.846331",
            "recid": 846331
        },
        "publication_date": "2021-06-18",
        "title": "A report about air pollution in Grenoble",
        "upload_type": "poster"
    },
    "modified": "2021-06-18T09:47:33.122768+00:00",
    "owner": 75563,
    "record_id": 846331,
    "state": "inprogress",
    "submitted": true,
    "title": "A report about air pollution in Grenoble"
}
#+end_example

Now either discard the changes or publish the deposit. Let's publish
it

#+begin_src python :results output :exports both
import requests
import json
ACCESS_TOKEN= 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/publish', params={'access_token': ACCESS_TOKEN})
print(json.dumps(r.json(), indent=4))
#+end_src

#+RESULTS:
#+begin_example
{
    "conceptdoi": "10.5072/zenodo.846330",
    "conceptrecid": "846330",
    "created": "2021-06-02T13:12:08.831740+00:00",
    "doi": "10.5072/zenodo.846331",
    "doi_url": "https://doi.org/10.5072/zenodo.846331",
    "files": [
        {
            "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
            "filename": "AirPollutionInGrenoble.pdf",
            "filesize": 1107977,
            "id": "8b14ada3-07a2-4da4-a0af-6c18ce58ced4",
            "links": {
                "download": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca/AirPollutionInGrenoble.pdf",
                "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files/8b14ada3-07a2-4da4-a0af-6c18ce58ced4"
            }
        }
    ],
    "id": 846331,
    "links": {
        "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846331.svg",
        "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
        "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846330.svg",
        "conceptdoi": "https://doi.org/10.5072/zenodo.846330",
        "doi": "https://doi.org/10.5072/zenodo.846331",
        "latest": "https://sandbox.zenodo.org/api/records/846331",
        "latest_html": "https://sandbox.zenodo.org/record/846331",
        "record": "https://sandbox.zenodo.org/api/records/846331",
        "record_html": "https://sandbox.zenodo.org/record/846331"
    },
    "metadata": {
        "access_right": "open",
        "communities": [
            {
                "identifier": "zenodo"
            }
        ],
        "creators": [
            {
                "affiliation": "St",
                "name": "H, O"
            },
            {
                "affiliation": "St",
                "name": "C, M"
            }
        ],
        "description": "report written by two students",
        "doi": "10.5072/zenodo.846331",
        "license": "CC-BY-4.0",
        "prereserve_doi": {
            "doi": "10.5072/zenodo.846331",
            "recid": 846331
        },
        "publication_date": "2021-06-18",
        "title": "A report about air pollution in Grenoble",
        "upload_type": "poster"
    },
    "modified": "2021-06-18T09:51:07.650592+00:00",
    "owner": 75563,
    "record_id": 846331,
    "state": "done",
    "submitted": true,
    "title": "A report about air pollution in Grenoble"
}
#+end_example
