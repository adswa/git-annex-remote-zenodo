#+TITLE:       lab book
#+AUTHOR:      Oumaima Hajji
#+STARTUP: overview indent inlineimages logdrawer
#+TAGS: R(R) Python(p) OrgMode(O) 


* Monday 31/05.

** first step: get.
  We start off by writing a small function to test the get query on
  the API. To do this, it is imperative to have the token (can
  be easily created on sandbox.zenodo) and have the access to do all
  queries. 

  #+begin_src python :results output :exports both
import requests
import json
def api():
    # get 
    ACCESS_TOKEN = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'
    r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions', params={'access_token': ACCESS_TOKEN})
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))

api()
#+end_src

  #+RESULTS:
  #+begin_example
  200
  [
      {
	  "conceptrecid": "844528",
	  "created": "2021-06-01T08:33:34.266269",
	  "id": 844529,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844529/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844529/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844529/files",
	      "html": "https://sandbox.zenodo.org/deposit/844529",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844529/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844529"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844529",
		  "recid": 844529
	      }
	  },
	  "modified": "2021-06-01T08:33:34.266278",
	  "owner": 72937,
	  "record_id": 844529,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844522",
	  "created": "2021-06-01T08:33:24.802909",
	  "id": 844523,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844523/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844523/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844523/files",
	      "html": "https://sandbox.zenodo.org/deposit/844523",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844523/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844523"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844523",
		  "recid": 844523
	      }
	  },
	  "modified": "2021-06-01T08:33:24.802918",
	  "owner": 72937,
	  "record_id": 844523,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844458",
	  "created": "2021-06-01T07:39:16.531542",
	  "id": 844459,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844459/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844459/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844459/files",
	      "html": "https://sandbox.zenodo.org/deposit/844459",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844459/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844459"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844459",
		  "recid": 844459
	      }
	  },
	  "modified": "2021-06-01T07:39:16.531556",
	  "owner": 72937,
	  "record_id": 844459,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844456",
	  "created": "2021-06-01T07:39:12.578429",
	  "id": 844457,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844457/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844457/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844457/files",
	      "html": "https://sandbox.zenodo.org/deposit/844457",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844457/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844457"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844457",
		  "recid": 844457
	      }
	  },
	  "modified": "2021-06-01T07:39:12.578441",
	  "owner": 72937,
	  "record_id": 844457,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844454",
	  "created": "2021-06-01T07:39:08.535444",
	  "id": 844455,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844455/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844455/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844455/files",
	      "html": "https://sandbox.zenodo.org/deposit/844455",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844455/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844455"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844455",
		  "recid": 844455
	      }
	  },
	  "modified": "2021-06-01T07:39:08.535460",
	  "owner": 72937,
	  "record_id": 844455,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844203",
	  "created": "2021-06-01T00:54:44.267674",
	  "id": 844204,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844204/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844204/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844204/files",
	      "html": "https://sandbox.zenodo.org/deposit/844204",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844204/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844204"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844204",
		  "recid": 844204
	      }
	  },
	  "modified": "2021-06-01T00:54:44.267682",
	  "owner": 72937,
	  "record_id": 844204,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844199",
	  "created": "2021-06-01T00:53:24.332368",
	  "id": 844200,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844200/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844200/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844200/files",
	      "html": "https://sandbox.zenodo.org/deposit/844200",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844200/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844200"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844200",
		  "recid": 844200
	      }
	  },
	  "modified": "2021-06-01T00:53:24.332376",
	  "owner": 72937,
	  "record_id": 844200,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844197",
	  "created": "2021-06-01T00:53:23.090962",
	  "id": 844198,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844198/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844198/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844198/files",
	      "html": "https://sandbox.zenodo.org/deposit/844198",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844198/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844198"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844198",
		  "recid": 844198
	      }
	  },
	  "modified": "2021-06-01T00:53:23.090971",
	  "owner": 72937,
	  "record_id": 844198,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844195",
	  "created": "2021-06-01T00:53:21.840632",
	  "id": 844196,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844196/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844196/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844196/files",
	      "html": "https://sandbox.zenodo.org/deposit/844196",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844196/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844196"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844196",
		  "recid": 844196
	      }
	  },
	  "modified": "2021-06-01T00:53:21.840641",
	  "owner": 72937,
	  "record_id": 844196,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      },
      {
	  "conceptrecid": "844193",
	  "created": "2021-06-01T00:53:20.538909",
	  "id": 844194,
	  "links": {
	      "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844194/actions/discard",
	      "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844194/actions/edit",
	      "files": "https://sandbox.zenodo.org/api/deposit/depositions/844194/files",
	      "html": "https://sandbox.zenodo.org/deposit/844194",
	      "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844194/actions/publish",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/844194"
	  },
	  "metadata": {
	      "prereserve_doi": {
		  "doi": "10.5072/zenodo.844194",
		  "recid": 844194
	      }
	  },
	  "modified": "2021-06-01T00:53:20.538926",
	  "owner": 72937,
	  "record_id": 844194,
	  "state": "unsubmitted",
	  "submitted": false,
	  "title": ""
      }
  ]
  #+end_example

  
** second step: post.
   Adding the argument headers to specify the content type because we
   want a json app. We also still need the access token because we
   can't make any query to the API without it.
   When we don't use the argument json={} we get an error and we can't
   use the response message to move on.

  #+begin_src python :results output :exports both
def apipost():
    import requests
    headers = {"Content-Type": "application/json"}
    params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, headers=headers)
    print(r.status_code)

apipost()

  #+end_src
  
  #+RESULTS:
  : 400

  Now that we've added the argument json={}, we get the message 201,
  meaning that the request succeeded.
  
  #+begin_src python :results output :exports both
def apipost():
    import json
    import requests
    headers = {"Content-Type": "application/json"}
    params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', json={}, params=params, headers=headers)
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))

apipost()

  #+end_src

  #+RESULTS:
  #+begin_example
  201
  {
      "conceptrecid": "844554",
      "created": "2021-06-01T08:40:17.198489+00:00",
      "files": [],
      "id": 844555,
      "links": {
	  "bucket": "https://sandbox.zenodo.org/api/files/c8b78c5d-39ed-42c2-bbf6-62d03c7ed06f",
	  "discard": "https://sandbox.zenodo.org/api/deposit/depositions/844555/actions/discard",
	  "edit": "https://sandbox.zenodo.org/api/deposit/depositions/844555/actions/edit",
	  "files": "https://sandbox.zenodo.org/api/deposit/depositions/844555/files",
	  "html": "https://sandbox.zenodo.org/deposit/844555",
	  "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/844555",
	  "latest_draft_html": "https://sandbox.zenodo.org/deposit/844555",
	  "publish": "https://sandbox.zenodo.org/api/deposit/depositions/844555/actions/publish",
	  "self": "https://sandbox.zenodo.org/api/deposit/depositions/844555"
      },
      "metadata": {
	  "prereserve_doi": {
	      "doi": "10.5072/zenodo.844555",
	      "recid": 844555
	  }
      },
      "modified": "2021-06-01T08:40:17.198497+00:00",
      "owner": 72937,
      "record_id": 844555,
      "state": "unsubmitted",
      "submitted": false,
      "title": ""
  }
  #+end_example

  
   Headers are not necessary here since "requests" automatically adds
   "Content-Type: application/json", because we're using the "json="
   keyword argument headers=headers.
   A test without the headers argument:
     
  #+begin_src python :results output :exports both
def apipost():
    import requests
    headers = {"Content-Type": "application/json"}
    params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', json={}, params=params)
    print(r.status_code)

apipost()

  #+end_src

  #+RESULTS:
  : 201

  
** step three: merging the two and posting on the API
   now we just write a bigger program where we do the necessary steps
   to communicate with the API in chronological order. First, we send
   a get request to check the access. Then, we create an empty
   depository and we upload a file.
   
  #+begin_src python :results output :exports both

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'
import os
import json
import requests

# method to handle all the basic queries
def query(query_method, url, headers=None, data=None):
    
    # making sure that the headers are specified before sending the request
    if headers is None:
        headers = {"Content-Type": "application/json"}
        
    # we use the same access key for all the queries.    
    params = {'access_token': KEY}

    # depending on the query, some of the arguments might be null
    if query_method == 'get':
        request = requests.get(url, params = params)
    else:
        if query_method == 'post': 
            request = requests.post(url, params=params, json={}, headers=headers)
        else:
            request = requests.put(url, params=params, json={}, data=data)
            
    # informing the user of the currint state of the operation        
    print("finished the " + query_method + "operation. Here is the returned message \n")
    print(request.status_code)

    #returning the resulting request for later uses
    return request


# this is the main method to call to transfer data
def transfer_store():
    # first step: get
    r = query('get', URL_SANDBOX)
    
    #creating an empty upload with post
    r = query('post', URL_SANDBOX)
    print(r.json())
    
    # now, we upload the file (cf the tips in the tutorial)
    # to do so, we will fetch the bucket_url which will be the folder containing the files
    URL_BUCKET = r.json()['links']['bucket']
        
    ID = r.json()['id']
    print(ID)

    # and then we upload it
    filename = 'AirPollutionInGrenoble.pdf'
    path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'
    #filename = input("inter the name of the file you want to send (ex: toto.zip) \n")
    #path = input("inter the path to the file (ex: /path/to/toto.zip) \n")

    # The target URL is a combination of the bucket link with the desired filename
    # seperated by a slash.
    with open(path, "rb") as fp:
        r = query('put', "%s/%s" % (URL_BUCKET, filename), data=fp)
        
    if r.status_code < 400:
        print("finished exporting the file... \n")

    
    r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % ID, params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    if r.status_code < 400:
        print("finished publishing the file... \n")


transfer_store()

  #+end_src

  #+RESULTS:
  #+begin_example
  finished the getoperation. Here is the returned message 

  200
  finished the postoperation. Here is the returned message 

  201
  {'conceptrecid': '844830', 'created': '2021-06-01T11:49:14.047438+00:00', 'files': [], 'id': 844831, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/21ea259d-d1ed-419f-92d0-f10585bda674', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/files', 'html': 'https://sandbox.zenodo.org/deposit/844831', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/844831', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/844831', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/844831/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844831'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.844831', 'recid': 844831}}, 'modified': '2021-06-01T11:49:14.047460+00:00', 'owner': 72937, 'record_id': 844831, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  844831
  finished the putoperation. Here is the returned message 

  200
  finished exporting the file... 

  401
  {
      "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
      "status": 401
  }
  #+end_example

  - new version with added functionalities

  #+begin_src python :results output :exports both

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'
import os
import json
import requests

# method to handle all the basic queries
def query(query_method, url, key_id=None,  headers=None, data=None):
    
    # making sure that the headers are specified before sending the request
    if headers is None:
        headers = {"Content-Type": "application/json"}
        
    # we use the same access key for all the queries.    
    params = {'access_token': KEY}

    # depending on the query, some of the arguments might be null
    if query_method == 'get':
        request = requests.get(url, params = params)
    else:
        if query_method == 'post': 
            request = requests.post(url, params=params, json={}, headers=headers)
        else:
            request = requests.put(url, params=params, json={}, data=data)
            
    # informing the user of the currint state of the operation        
    print("finished the " + query_method + "operation. Here is the returned message \n")
    print(request.status_code)

    #returning the resulting request for later uses
    return request


# this is the main method to call to transfer data
def transfer_store (key):
    # first step: get
    r = query('get', URL_SANDBOX)
    
    #creating an empty upload with post
    r = query('post', URL_SANDBOX)
    print(r.json())
    
    # now, we upload the file (cf the tips in the tutorial)
    # to do so, we will fetch the bucket_url which will be the folder containing the files
    URL_BUCKET = r.json()['links']['bucket']

    # and then we upload it
    filename = 'AirPollutionInGrenoble.pdf'
    path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'
    #filename = input("inter the name of the file you want to send (ex: toto.zip) \n")
    #path = input("inter the path to the file (ex: /path/to/toto.zip) \n")

    # The target URL is a combination of the bucket link with the desired filename
    # seperated by a slash.
    with open(path, "rb") as fp:
        r = query('put', "%s/%s" % (URL_BUCKET, filename), data=fp)

    print(r.json())
    """
    # now, we set the key in the remote by sending a put query
    deposition_id = r.json()['id']
    data = {'key_id': key}
    r = query('put', 'https://zenodo.org/api/deposit/depositions/%s' % deposition_id, data=json.dumps(data))
    """
    if r.status_code < 400:
        print("finished exporting the file... \n")


def transfer_retrieve(key):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved

        # get request to: https://sandbox.zenodo.org/api/deposit/depositions 
    uuuurl = 'https://sandbox.zenodo.org/api/deposit/depositions/844128/files'
    r = query('get', uuuurl)
    print(r.json())

#transfer_store('testet')
transfer_retrieve('testet')


  #+end_src

  #+RESULTS:
  : finished the getoperation. Here is the returned message 
  : 
  : 200
  : [{'checksum': '96379d6f2dfdbdd68ee0fa48a31ee07c', 'filename': 'AirPollutionInGrenoble.pdf', 'filesize': 1107977, 'id': 'd4ecf116-ff2d-4fcb-8c1e-c31065f73b31', 'links': {'download': 'https://sandbox.zenodo.org/api/files/28c34351-9840-4b62-b297-699ec90bd027/AirPollutionInGrenoble.pdf', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844088/files/d4ecf116-ff2d-4fcb-8c1e-c31065f73b31'}}]

  #+begin_src python :results output :exports both
import requests

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


class ZenodoRemote():

    def __init__(self):
        self.deposit = None
        self.deposit_id = None

    # method to handle all the basic queries
    def query(self, query_method: str, url, id=None, headers=None, data=None):
        # id = key (!= KEY or access token to the API): to be stored in the remote. 
        # In most cases, this is going to be the remote file name. It should be at 
        # least be unambigiously derived from it.
        import requests

        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        # for put / post   
        if id is not None:    
            params = {'access_token': KEY, 'identifier' : id}   
        # for get (when we don't have an identifier for the file, ie: when we still haven't uploaded it)
        else:
            params = {'access_token': KEY}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            request = requests.get(url, json={}, params = params)
        else:
            if query_method == 'post': 
                request = requests.post(url, params=params, json={}, headers=headers)
            else:
                request = requests.put(url, params=params, json={}, data=data)
                
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + "operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request


    # methods to implement
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        #self.key = input("inter the token \n")
	    KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


    def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use

        # let's try to connect to the API, if the status code is not 200: there is an error 
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
        
        # we first need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        print(r.json())

        self.deposit = r
        self.deposit_id = r.json()['id']
        # finished preparing the remote


    def transfer_store(self, key):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        # uploading the file:
        r = self.deposit
        # now, we upload the file (cf the tips in the tutorial)
        # to do so, we will fetch the bucket_url which will be the folder containing the files
        URL_BUCKET = r.json()["links"]["bucket"]

        # todo: extract the path and the filename from arg 'filename'

        # and then we upload it
        filename = 'notes.pdf'
        path = '/home/nubudi/Downloads/notes.pdf'
        
        # The target URL is a combination of the bucket link with the desired filename
        # seperated by a slash.
        with open(path, "rb") as fp:
            r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
        
        if r.status_code < 400:
            print("finished exporting the file... \n")
        
        # todo: publishing the file 
        # simply by using a post query

    def transfer_retrieve(self, key):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
	    
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        print(r.json())
        

    # Redirect output to stderr to avoid messing up the protocol
remote = ZenodoRemote()
remote.initremote()
remote.prepare()
remote.transfer_store('notes.pdf')
remote.transfer_retrieve('notes.pdf') 
  #+end_src

  #+RESULTS:
  #+begin_example
  finished the getoperation. Here is the returned message 

  200
  finished the postoperation. Here is the returned message 

  201
  {'conceptrecid': '844143', 'created': '2021-06-01T00:13:57.858160+00:00', 'files': [], 'id': 844144, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/4e680567-c908-4a94-88b0-af5ab11551f6', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/files', 'html': 'https://sandbox.zenodo.org/deposit/844144', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/844144', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/844144', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844144'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.844144', 'recid': 844144}}, 'modified': '2021-06-01T00:13:57.858173+00:00', 'owner': 72937, 'record_id': 844144, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  finished the putoperation. Here is the returned message 

  200
  finished exporting the file... 

  finished the getoperation. Here is the returned message 

  200
  [{'checksum': '2d2d364fe89375260446330175bd832f', 'filename': 'notes.pdf', 'filesize': 180064, 'id': 'a05fa9ca-0087-4c3f-9915-4e657e39312e', 'links': {'download': 'https://sandbox.zenodo.org/api/files/4e680567-c908-4a94-88b0-af5ab11551f6/notes.pdf', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844144/files/a05fa9ca-0087-4c3f-9915-4e657e39312e'}}]
  #+end_example

  
** fct
  #+begin_src python :results output :exports both
import requests

URL_SANDBOX = 'https://sandbox.zenodo.org/api/deposit/depositions'
KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


class ZenodoRemote():

    def __init__(self):
        self.deposit = None
        self.deposit_id = None

    # method to handle all the basic queries
    def query(self, query_method: str, url, id=None, headers=None, data=None):
        # id = key (!= KEY or access token to the API): to be stored in the remote. 
        # In most cases, this is going to be the remote file name. It should be at 
        # least be unambigiously derived from it.
        import requests

        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        # for put / post   
        if id is not None:    
            params = {'access_token': KEY, 'identifier' : id}   
        # for get (when we don't have an identifier for the file, ie: when we still haven't uploaded it)
        else:
            params = {'access_token': KEY}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            request = requests.get(url, json={}, params = params)
        else:
            if query_method == 'post': 
                request = requests.post(url, params=params, json={}, headers=headers)
            else:
                request = requests.put(url, params=params, json={}, data=data)
                
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + "operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request


    # methods to implement
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        #self.key = input("inter the token \n")
	    KEY = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'


    def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use

        # let's try to connect to the API, if the status code is not 200: there is an error 
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
        
        # we first need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        print(r.json())

        self.deposit = r
        self.deposit_id = r.json()['id']
        # finished preparing the remote


    def transfer_store(self, key):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        # uploading the file:
        r = self.deposit
        # now, we upload the file (cf the tips in the tutorial)
        # to do so, we will fetch the bucket_url which will be the folder containing the files
        URL_BUCKET = r.json()["links"]["bucket"]

        # todo: extract the path and the filename from arg 'filename'

        # and then we upload it
        filename = 'notes.pdf'
        path = '/home/nubudi/Downloads/notes.pdf'
        
        # The target URL is a combination of the bucket link with the desired filename
        # seperated by a slash.
        with open(path, "rb") as fp:
            r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
        
        with open('/home/nubudi/Downloads/AirPollutionInGrenoble.pdf', "rb") as fp:
            r = self.query('put', "%s/%s" % (URL_BUCKET, 'AirPollutionInGrenoble.pdf'), key, data=fp)
        

        if r.status_code < 400:
            print("finished exporting the file... \n")
        
        # todo: publishing the file 
        # simply by using a post query

    def transfer_retrieve(self, key):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
	    
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        for i in range(len(r.json())):
            if r.json()[i]['filename'] == key:
                print('yes, this file exists in the remote: ' + key )
                return True
        return False 

    # Redirect output to stderr to avoid messing up the protocol
remote = ZenodoRemote()
remote.initremote()
remote.prepare()
remote.transfer_store('notes.pdf')
remote.transfer_retrieve('notes.pdf')
    

  #+end_src

  #+RESULTS:
  #+begin_example
  finished the getoperation. Here is the returned message 

  200
  finished the postoperation. Here is the returned message 

  201
  {'conceptrecid': '844652', 'created': '2021-06-01T09:52:04.046805+00:00', 'files': [], 'id': 844653, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/fb4504f0-cd8b-4eed-ba47-1de6197ee38d', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/files', 'html': 'https://sandbox.zenodo.org/deposit/844653', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/844653', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/844653', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/844653'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.844653', 'recid': 844653}}, 'modified': '2021-06-01T09:52:04.046814+00:00', 'owner': 72937, 'record_id': 844653, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  finished the putoperation. Here is the returned message 

  200
  finished the putoperation. Here is the returned message 

  200
  finished exporting the file... 

  finished the getoperation. Here is the returned message 

  200
  yes, this file exists in the remote: notes.pdf
  #+end_example




  #+begin_src shell :session *shell* :results output :exports both 
cd code
chmod +x git-annex-remote-zenodo
  #+end_src

  #+RESULTS:


    #+begin_src shell :session *shell* :results output :exports both 
git init
git annex init
export PATH=$PATH:/path_to_file
git annex initremote choose_name externaltype=zenodo encryption=none type=external
  #+end_src

  #+RESULTS:
  : Initialized empty Git repository in /home/nubudi/Desktop/Internship/code/.git/
  : init  ok
  : (recording state in git...)




  # New version

  - publishing and creating a new version.
    
    #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
id_last_version =  '844653'
ACCESS_TOKEN = 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/844653', params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})

print(r.status_code)

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/844653/actions/publish', params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

    #+end_src

    #+RESULTS:
    : 200
    : 401
    : {
    :     "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
    :     "status": 401
    : }

  

  

* Tuesday 01/06.
** new test with a new access token.
   #+begin_src python :results output :exports both
import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)
print(r.json())

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

print(r.json())

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:
   : 201
   : {'conceptrecid': '845104', 'created': '2021-06-01T14:08:14.923411+00:00', 'files': [], 'id': 845105, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/files', 'html': 'https://sandbox.zenodo.org/deposit/845105', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/845105', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/845105', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/845105/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/845105'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.845105', 'recid': 845105}}, 'modified': '2021-06-01T14:08:14.923420+00:00', 'owner': 72937, 'record_id': 845105, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
   : {'mimetype': 'application/pdf', 'updated': '2021-06-01T14:08:15.247795+00:00', 'links': {'self': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70/AirPollutionInGrenoble.pdf', 'version': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70/AirPollutionInGrenoble.pdf?versionId=0df5f345-2925-46ad-b420-28b996700d82', 'uploads': 'https://sandbox.zenodo.org/api/files/2ebaa15a-675b-447d-a2d1-fbb1a6c17b70/AirPollutionInGrenoble.pdf?uploads'}, 'is_head': True, 'created': '2021-06-01T14:08:15.243098+00:00', 'checksum': 'md5:96379d6f2dfdbdd68ee0fa48a31ee07c', 'version_id': '0df5f345-2925-46ad-b420-28b996700d82', 'delete_marker': False, 'key': 'AirPollutionInGrenoble.pdf', 'size': 1107977}
   : 401
   : {
   :     "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
   :     "status": 401
   : }



  look into this: test if we can make a new version of a deposit that is
  not published.

  - first try without having already published the deposit that we
    will be creating a new version of.

  #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

concept_id = r.json()["conceptrecid"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})
print(r.status_code)

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7f0Y'}, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id , params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})
print(r.status_code)


id = 845033
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/newversion?access_token=kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY' % id, json={} , headers={"Content-Type": "application/json"})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

  #+end_src

  #+RESULTS:
  #+begin_example
  201
  200
  401
  {
      "message": "The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.",
      "status": 401
  }
  200
  201
  {
      "conceptdoi": "10.5072/zenodo.845032",
      "conceptrecid": "845032",
      "created": "2021-06-01T13:29:15.931719+00:00",
      "doi": "10.5072/zenodo.845033",
      "doi_url": "https://doi.org/10.5072/zenodo.845033",
      "files": [
	  {
	      "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	      "filename": "AirPollutionInGrenoble.pdf",
	      "filesize": 1107977,
	      "id": "509b0d36-afaf-4e83-87a2-e75af144ef4d",
	      "links": {
		  "download": "https://sandbox.zenodo.org/api/files/a7c73360-8ccc-4d3b-b38e-39c03025e043/AirPollutionInGrenoble.pdf",
		  "self": "https://sandbox.zenodo.org/api/deposit/depositions/845033/files/509b0d36-afaf-4e83-87a2-e75af144ef4d"
	      }
	  }
      ],
      "id": 845033,
      "links": {
	  "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845033.svg",
	  "bucket": "https://sandbox.zenodo.org/api/files/a7c73360-8ccc-4d3b-b38e-39c03025e043",
	  "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845032.svg",
	  "conceptdoi": "https://doi.org/10.5072/zenodo.845032",
	  "doi": "https://doi.org/10.5072/zenodo.845033",
	  "latest": "https://sandbox.zenodo.org/api/records/845033",
	  "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/845066",
	  "latest_draft_html": "https://sandbox.zenodo.org/deposit/845066",
	  "latest_html": "https://sandbox.zenodo.org/record/845033",
	  "record": "https://sandbox.zenodo.org/api/records/845033",
	  "record_html": "https://sandbox.zenodo.org/record/845033"
      },
      "metadata": {
	  "access_right": "open",
	  "communities": [
	      {
		  "identifier": "zenodo"
	      }
	  ],
	  "creators": [
	      {
		  "name": "Oumaima HAJJI",
		  "orcid": "0000-0001-6353-0584"
	      }
	  ],
	  "description": "<p>test</p>",
	  "doi": "10.5072/zenodo.845033",
	  "license": "CC-BY-4.0",
	  "prereserve_doi": {
	      "doi": "10.5072/zenodo.845033",
	      "recid": 845033
	  },
	  "publication_date": "2021-06-01",
	  "publication_type": "article",
	  "title": "test",
	  "upload_type": "publication"
      },
      "modified": "2021-06-01T13:47:18.904756+00:00",
      "owner": 72937,
      "record_id": 845033,
      "state": "done",
      "submitted": true,
      "title": "test"
  }
  #+end_example


this is a test using a deposit that has been published privately

  #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

concept_id = r.json()["conceptrecid"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})
print(r.status_code)

id = 845065
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/newversion?access_token=kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY' % id, json={} , headers={"Content-Type": "application/json"})
print(r.status_code)
print(json.dumps(r.json(), indent=4))
  #+end_src

  #+RESULTS:
  #+begin_example
  201
  200
  201
  {
      "conceptdoi": "10.5072/zenodo.845064",
      "conceptrecid": "845064",
      "created": "2021-06-01T13:50:47.257899+00:00",
      "doi": "10.5072/zenodo.845065",
      "doi_url": "https://doi.org/10.5072/zenodo.845065",
      "files": [
	  {
	      "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	      "filename": "AirPollutionInGrenoble.pdf",
	      "filesize": 1107977,
	      "id": "a20de20a-2e91-4117-82d2-f220b6332129",
	      "links": {
		  "download": "https://sandbox.zenodo.org/api/files/89883821-8f6c-4047-a2ce-0c5ab10a8bfc/AirPollutionInGrenoble.pdf",
		  "self": "https://sandbox.zenodo.org/api/deposit/depositions/845065/files/a20de20a-2e91-4117-82d2-f220b6332129"
	      }
	  }
      ],
      "id": 845065,
      "links": {
	  "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845065.svg",
	  "bucket": "https://sandbox.zenodo.org/api/files/89883821-8f6c-4047-a2ce-0c5ab10a8bfc",
	  "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.845064.svg",
	  "conceptdoi": "https://doi.org/10.5072/zenodo.845064",
	  "doi": "https://doi.org/10.5072/zenodo.845065",
	  "latest": "https://sandbox.zenodo.org/api/records/845065",
	  "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/845081",
	  "latest_draft_html": "https://sandbox.zenodo.org/deposit/845081",
	  "latest_html": "https://sandbox.zenodo.org/record/845065",
	  "record": "https://sandbox.zenodo.org/api/records/845065",
	  "record_html": "https://sandbox.zenodo.org/record/845065"
      },
      "metadata": {
	  "access_right": "closed",
	  "communities": [
	      {
		  "identifier": "zenodo"
	      }
	  ],
	  "creators": [
	      {
		  "name": "Oumaima Hajji",
		  "orcid": "0000-0001-6353-0584"
	      }
	  ],
	  "description": "<p>this is a test</p>",
	  "doi": "10.5072/zenodo.845065",
	  "prereserve_doi": {
	      "doi": "10.5072/zenodo.845065",
	      "recid": 845065
	  },
	  "publication_date": "2021-06-01",
	  "publication_type": "article",
	  "title": "test_closed_version",
	  "upload_type": "publication"
      },
      "modified": "2021-06-01T14:06:00.869938+00:00",
      "owner": 72937,
      "record_id": 845065,
      "state": "done",
      "submitted": true,
      "title": "test_closed_version"
  }
  #+end_example



** test: creating a deposit and putting files inside and then deleting
  the deposit and trying to access the files directly with an url


  #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers=headers)
print(r.status_code)
print(r.json())

bucket_url = r.json()["links"]["bucket"]
bucket_id = r.json()["id"]

filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

filename = 'notes.pdf'
path = '/home/nubudi/Downloads/notes.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(bucket_id) + '/files'
r = requests.get(url, params=params)

print(json.dumps(r.json(), indent=4))

  #+end_src

  #+RESULTS:
  #+begin_example
  201
  {'conceptrecid': '846316', 'created': '2021-06-02T13:00:02.044350+00:00', 'files': [], 'id': 846317, 'links': {'bucket': 'https://sandbox.zenodo.org/api/files/2197cc94-bb26-4958-8bee-5d3111346d8a', 'discard': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/actions/discard', 'edit': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/actions/edit', 'files': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/files', 'html': 'https://sandbox.zenodo.org/deposit/846317', 'latest_draft': 'https://sandbox.zenodo.org/api/deposit/depositions/846317', 'latest_draft_html': 'https://sandbox.zenodo.org/deposit/846317', 'publish': 'https://sandbox.zenodo.org/api/deposit/depositions/846317/actions/publish', 'self': 'https://sandbox.zenodo.org/api/deposit/depositions/846317'}, 'metadata': {'prereserve_doi': {'doi': '10.5072/zenodo.846317', 'recid': 846317}}, 'modified': '2021-06-02T13:00:02.044360+00:00', 'owner': 75563, 'record_id': 846317, 'state': 'unsubmitted', 'submitted': False, 'title': ''}
  [
      {
	  "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	  "filename": "AirPollutionInGrenoble.pdf",
	  "filesize": 1107977,
	  "id": "7c75fc07-a11b-432e-b8a1-2c7ebd96c060",
	  "links": {
	      "download": "https://sandbox.zenodo.org/api/files/2197cc94-bb26-4958-8bee-5d3111346d8a/AirPollutionInGrenoble.pdf",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/846317/files/7c75fc07-a11b-432e-b8a1-2c7ebd96c060"
	  }
      },
      {
	  "checksum": "2d2d364fe89375260446330175bd832f",
	  "filename": "notes.pdf",
	  "filesize": 180064,
	  "id": "01b77826-1ecb-478f-9853-bddc98a3cb3a",
	  "links": {
	      "download": "https://sandbox.zenodo.org/api/files/2197cc94-bb26-4958-8bee-5d3111346d8a/notes.pdf",
	      "self": "https://sandbox.zenodo.org/api/deposit/depositions/846317/files/01b77826-1ecb-478f-9853-bddc98a3cb3a"
	  }
      }
  ]
  #+end_example


 before deleting the deposit, we can use the links 'self' and
 'download' to access the files. We then delete the deposit. This
 could be done easily via the user interface (the url is in this case
 https://sandbox.zenodo.org/deposit/845189, 845189 could be exchanged
 with the id of any deposit that we have created)
 Now, we only have to retry to access the files through the url given
 in the response message when we uploaded them in the deposit.

 #+begin_src python :results output :exports both
import requests
import json

print("trying to access the files with the download link \n")
r = requests.get("https://sandbox.zenodo.org/api/files/679deb7b-69cf-4499-bc6c-dc6c2e285678/notes.pdf", params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})
print(json.dumps(r.json(), indent=4))


print("trying to access the files with the self link")
r = requests.get("https://sandbox.zenodo.org/api/deposit/depositions/845189/files/017b9d94-8fed-4655-a11e-74b020e19a61", params={'access_token': 'kBs8SX4CBQmUQb3ygRn3HkmZNgDoIGzYzdW2wuuBv5xQpQmZ2zzJo6iql7fY'})
print(json.dumps(r.json(), indent=4))

#+end_src

#+RESULTS:
#+begin_example
trying to access the files with the download link 

{
    "message": "Bucket does not exist.",
    "status": 404
}
trying to access the files with the self link
{
    "status": 410,
    "message": "PID has been deleted."
}
#+end_example
 

As we can see in the response to the get query we sent, the files can
no longer be accessed via the urls.


** retrying to publish by adding some metadata before senfing the request

   #+begin_src python :results output :exports both
import requests
import json

ACCESS_TOKEN = '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'
r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions', params={'access_token': ACCESS_TOKEN})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

headers = {"Content-Type": "application/json"}
params = {'access_token': '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'}
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={})

print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:

   
   #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'}

bucket_id = 845033

data = {
     'metadata': {
         'title': 'My first upload',
         'upload_type': 'poster',
         'description': 'This is my first upload',
         'creators': [{'name': 'Doe, John',
                       'affiliation': 'Zenodo'}]
     }
}

r = requests.put('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id, params=params, data=json.dumps(data), headers=headers, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params={'access_token': '6sqEMQpgWZUUNFg3G3rTyzSTAQGKeM0po9PLtedL42gzEC2RG3yTjK4uBcu3'}, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src


* Wednesday 02/06.

** publishing through the api.

    retrying to publish by adding some metadata before senfing the request

    - first: creating the deposit
   #+begin_src python :results output :exports both
import requests
import json

ACCESS_TOKEN = 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'
headers = {"Content-Type": "application/json"}
params = {'access_token': ACCESS_TOKEN}

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions', params=params)
print(r.status_code)
print(json.dumps(r.json(), indent=4))


r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions', params=params, json={}, headers= headers)
print(r.json()["id"])
print(r.json()["links"]["bucket"])

print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:
   #+begin_example
   200
   []
   846331
   https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca
   201
   {
       "conceptrecid": "846330",
       "created": "2021-06-02T13:12:08.831740+00:00",
       "files": [],
       "id": 846331,
       "links": {
	   "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
	   "discard": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/discard",
	   "edit": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/edit",
	   "files": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files",
	   "html": "https://sandbox.zenodo.org/deposit/846331",
	   "latest_draft": "https://sandbox.zenodo.org/api/deposit/depositions/846331",
	   "latest_draft_html": "https://sandbox.zenodo.org/deposit/846331",
	   "publish": "https://sandbox.zenodo.org/api/deposit/depositions/846331/actions/publish",
	   "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331"
       },
       "metadata": {
	   "prereserve_doi": {
	       "doi": "10.5072/zenodo.846331",
	       "recid": 846331
	   }
       },
       "modified": "2021-06-02T13:12:08.831748+00:00",
       "owner": 75563,
       "record_id": 846331,
       "state": "unsubmitted",
       "submitted": false,
       "title": ""
   }
   #+end_example

     
   #+begin_src python :results output :exports both

import requests
import json

headers = {"Content-Type": "application/json"}
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}

bucket_id = 846331  # we get this by choosing the id of one of the deposits we created

r = requests.get('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id, params=params)
print(r.status_code)

# getting the url of the bucket using the id that we have
# to do this, we go through the list of the deposits that we have created and compare the id
"""
found = False
for i in range(2):
    if r.json()[i]["id"] == bucket_id:
        bucket_url =  r.json()[i]["links"]["bucket"]
        found = True
if found == False:
    print("oups, couldn't find the bucket url using this id")

print(bucket_url)
"""

# getting the url
bucket_url = r.json()["links"]["bucket"]

# uploading a file to the deposit
filename = 'AirPollutionInGrenoble.pdf'
path = '/home/nubudi/Downloads/AirPollutionInGrenoble.pdf'

with open(path, "rb") as fp:
    r = requests.put("%s/%s" % (bucket_url, filename), data=fp, params=params, json={})

# adding metadata to the deposit
data = {
     'metadata': {
         'title': 'Air pollution in Grenoble',
         'upload_type': 'poster',
         'description': 'first upload',
         'creators': [{'name': 'H, O',
                       'affiliation': 'Zenodo'}]
     }
}

r = requests.put('https://sandbox.zenodo.org/api/deposit/depositions/%s' % bucket_id, params=params, data=json.dumps(data), headers=headers, json={})
print(r.status_code)

# publishing
r = requests.post('https://sandbox.zenodo.org/api/deposit/depositions/%s/actions/publish' % bucket_id , params=params, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))

   #+end_src

   #+RESULTS:
   #+begin_example
   200
   200
   202
   {
       "conceptdoi": "10.5072/zenodo.846330",
       "conceptrecid": "846330",
       "created": "2021-06-02T13:12:08.831740+00:00",
       "doi": "10.5072/zenodo.846331",
       "doi_url": "https://doi.org/10.5072/zenodo.846331",
       "files": [
	   {
	       "checksum": "96379d6f2dfdbdd68ee0fa48a31ee07c",
	       "filename": "AirPollutionInGrenoble.pdf",
	       "filesize": 1107977,
	       "id": "8b14ada3-07a2-4da4-a0af-6c18ce58ced4",
	       "links": {
		   "download": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca/AirPollutionInGrenoble.pdf",
		   "self": "https://sandbox.zenodo.org/api/deposit/depositions/846331/files/8b14ada3-07a2-4da4-a0af-6c18ce58ced4"
	       }
	   }
       ],
       "id": 846331,
       "links": {
	   "badge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846331.svg",
	   "bucket": "https://sandbox.zenodo.org/api/files/7a78a251-8631-47e4-be50-4207854145ca",
	   "conceptbadge": "https://sandbox.zenodo.org/badge/doi/10.5072/zenodo.846330.svg",
	   "conceptdoi": "https://doi.org/10.5072/zenodo.846330",
	   "doi": "https://doi.org/10.5072/zenodo.846331",
	   "latest": "https://sandbox.zenodo.org/api/records/846331",
	   "latest_html": "https://sandbox.zenodo.org/record/846331",
	   "record": "https://sandbox.zenodo.org/api/records/846331",
	   "record_html": "https://sandbox.zenodo.org/record/846331"
       },
       "metadata": {
	   "access_right": "open",
	   "communities": [
	       {
		   "identifier": "zenodo"
	       }
	   ],
	   "creators": [
	       {
		   "affiliation": "Zenodo",
		   "name": "H, O"
	       }
	   ],
	   "description": "first upload",
	   "doi": "10.5072/zenodo.846331",
	   "license": "CC-BY-4.0",
	   "prereserve_doi": {
	       "doi": "10.5072/zenodo.846331",
	       "recid": 846331
	   },
	   "publication_date": "2021-06-02",
	   "title": "Air pollution in Grenoble",
	   "upload_type": "poster"
       },
       "modified": "2021-06-02T13:18:25.798500+00:00",
       "owner": 75563,
       "record_id": 846331,
       "state": "done",
       "submitted": true,
       "title": "Air pollution in Grenoble"
   }
   #+end_example


* Thursday 03/06.
  We will be using the Python library that already implements the
  external special remote protocol in order to create the new remote
  for Zenodo.
  Link: https://github.com/Lykos153/AnnexRemote

  The blueprint of the class is given with a few methods to
  implement. 

** Step 0: init.
   Initiating the instances of this class by defining the main
   attributes that are needed for the remote to function. This is
   where we define the key that is used to do all the basic API
   queries and where we initiate the id of the deposit that will be
   created once the remote is initiated with initremote.  

      #+begin_src python :results output :exports both
    def __init__(self, *args):
        self.deposit = None
        self.deposit_id = None
        self.deposit_bucket = None
        self.key = ''
      #+end_src

   
** Step 1: query.
   This is the method that we will be using to handle the basic
   queries to the API.
   
     #+begin_src python :results output :exports both
    def query(self, query_method, url, id=None, headers=None, data=None):
        # making sure that the headers are specified before sending the request
        if headers is None:
            headers = {"Content-Type": "application/json"}

        # we use the same access key for all the queries. 
        # for put / post   
        if id is not None:    
            params = {'access_token': self.key, 'identifier' : id}   
        # for get (when we don't have an identifier for the file, ie: when we still haven't uploaded it)
        else:
            params = {'access_token': self.key}

        # depending on the query, some of the arguments might be null
        if query_method == 'get':
            request = requests.get(url, params = params)
        else:
            if query_method == 'post': 
                request = requests.post(url, params=params, json={}, headers=headers)
            else:
                request = requests.put(url, params=params, json={}, data=data)
                
        # informing the user of the currint state of the operation        
        print("finished the " + query_method + " operation. Here is the returned message \n")
        print(request.status_code)
        #returning the resulting request for later uses
        return request
        
    #+end_src

    
** Step 2: initremote.
   "Gets called when git annex initremote or git annex enableremote are
   run. This is where any one-time setup tasks can be done, for
   example creating the remote folder. Note: This may be run
   repeatedly over time, as a remote is initialized in different
   repositories, or as the configuration of a remote is changed."
   
   We can fetch the access token (given by the user as an argument
   while initializing the remote) by using the function getconfig.  
   We then create an upload by sending a post request to the API. 
   We fetch the id of the bucket and the url of the bucket so that we
   can use it in the other functions.
   
    #+begin_src python :results output :exports both
    def initremote(self):
    # initialize the remote, eg. create the folders
    # raise RemoteError if the remote couldn't be initialized
        import requests
        # need to get the key by using the getconfig method
        # the key is passed as an argument when using the commant initremote (ex: key='')
        self.key = self.annex.getconfig('key')
        # if it's not been added as an argument, we raise an 
        if not self.key:
            raise RemoteError("You need to add the access token (key = TOKEN)")

        # now, we need to create an empty upload that we will be using from now on
        r = self.query('post', URL_SANDBOX)
        if r.status_code > 204:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a post query to the API')
        
        # setting the id for this deposit
        self.deposit = r
        self.deposit_id = r.json()['id']
        self.deposit_bucket = r.json()['links']['bucket']
        
    #+end_src

    
** Step 3: prepare.
    "Tells the remote that it's time to prepare itself to be used. Gets
    called whenever git annex is about to access any of the below
    methods, so it shouldn't be too expensive."

    We send a get request to the API just to make sure that the
    connection to the API is well established and that there is no
    problem with the access token for instance.

    #+begin_src python :results output :exports both
      def prepare(self):
        # prepare to be used, eg. open TCP connection, authenticate with the server etc.
        # raise RemoteError if not ready to use
          
        import requests
        # let's try to connect to the API, if the status code is not 200: there is an error 
        r = self.query('get', URL_SANDBOX)
        if r.status_code != 200:
            print("error while preparing the remote: cannot communicate with the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')
        
    #+end_src    

    
** Step 4: transferstore.
"Store the file in localfile to a unique location derived from key."

We only need to upload the file into the deposit. This is done by
getting the url of the deposit that was created and by then making a
put request to the API to send the file.
    
    #+begin_src python :results output :exports both
    def transfer_store(self, key, filename):
        # store the file in `filename` to a unique location derived from `key`
        # raise RemoteError if the file couldn't be stored
        
        try:
            # fetching the url of the bucket
            URL_BUCKET = self.deposit_bucket

            # and then we upload it

            #filename = 'notes.pdf'
            #path = '/home/nubudi/Downloads/notes.pdf'

            # extracting the filename and the path from filename
            # the argument filename of the function contains the full path to the path.
            # we  can get the name of the file by using the function rsplit to split 
            # the string at the specified separator '/' and we can get the filename by 
            # getting the lest element of the file.
            list = filename.rsplit("/")
            file = list[-1]
            path = filename

            # The target URL is a combination of the bucket link with the desired filename
            # seperated by a slash.
            with open(path, "rb") as fp:
                r = self.query('put', "%s/%s" % (URL_BUCKET, filename), key, data=fp)
            
            if r.status_code < 400:
                print("finished exporting the file... \n")
            else:
                raise RemoteError ('error while exporting the file... \n')

        except Exception as error:
            raise RemoteError(error)
    #+end_src

    
** Step 5: transferretrieve.
"Get the file identified by key from the remote and store it in
localfile."

We check if the file exists by comparing the key (= the name of the
file in this case) and then we send a get request to check information
on the file.

#+begin_src python :results output :exports both

#+end_src

      #+begin_src python :results output :exports both
    def checkpresent(self, key, filename):
        # return True if the key is present in the remote
        # return False if the key is not present
        # raise RemoteError if the presence of the key couldn't be determined, eg. in case of connection error

        try:
            url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
            r = self.query('get', url)
            # going through the list of the files in this deposit
            for i in range(len(r.json())):
                if r.json()[i]['filename'] == key:
                    url = r.json()[i]['links']['download']
                    r = self('get', url)   
        except Exception as error:
            raise RemoteError(error)

      #+end_src

      
** Step 6: checkpresent.
"Requests the remote to check if a key is present in it."

We can compare the key to the files that are already stored in the
deposit and then return true or false depending on the case. If there
is a problem with the determining of this, we can raise an exception.

    #+begin_src python :results output :exports both
    def checkpresent(self, key):
        # return True if the key is present in the remote
        # return False if the key is not present
        # raise RemoteError if the presence of the key couldn't be determined, eg. in case of connection error

        try:
            url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
            r = self.query('get', url)
            # going through the list of the files in this deposit
            for i in range(len(r.json())):
                if r.json()[i]['filename'] == key:
                    print('yes, this file exists in the remote: ' + key )
                    return True
            return False 
            
        except Exception as error:
            raise RemoteError(error)
    #+end_src

    


* Friday 04/06.
** fetching and downloading files.

- Writing this function to fetch a particular file from the the
deposit. This is done by looking up a file in the deposit that has a
name that is the same as the key that is passed to the function. We
can then get other information about this file in the same
response. The url that could be useful is for instance the download
link.

#+begin_src python :results output :exports both
import requests
import json

params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
deposit_id = 846331
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'
r = requests.get(url, params = params)
# going through the list of the files in this deposit
for i in range(len(r.json())):
    # checking if the file exists by comparing the key/filename
    # sending a get request to check information on the file
    if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
        # we can retrieve a single deposition file with: 
        #url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files/' + str(file_id)
        # getting the id of the file that we want to download
        file_id =  r.json()[i]['id']
        # getting the download link of the file
        url = r.json()[i]['links']['download']
        r = requests.get(url, params = params)
        #print(json.dumps(r.json(), indent=4))
        print(r.status_code)
        
#+end_src

#+RESULTS:
: 200


- We can now retrieve the file using the same logic and then writing
  the content of the file into a new file locally.
  
#+begin_src python :results output :exports both
import requests
import json

params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
deposit_id = 846331
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'
r = requests.get(url, params = params)
# going through the list of the files in this deposit
for i in range(len(r.json())):
    # checking if the file exists by comparing the key/filename
    # sending a get request to check information on the file
    if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
        # getting the id of the file that we want to download
        file_id =  r.json()[i]['id']
        # getting the download link of the file
        url = r.json()[i]['links']['download']
        
        r = requests.get(url, params = params, stream=True)
        r.raise_for_status()
        print(r.status_code)
        with open("test_download", "wb") as f:
            for chunk in r.iter_content(chunk_size=120): 
                f.write(chunk)
        f.close()

#+end_src

#+RESULTS:
: 200

By implementing in the function transferretrieve, we can now retrieve
the files we want from the remote just by giving the key (ie the name
of the file) and the path where we want it to be stored. This is how
the function looks now:

#+begin_example
    def transfer_retrieve(self, key, filename):
        # get the file identified by `key` and store it to `filename`
        # raise RemoteError if the file couldn't be retrieved
        import json

        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)

        # going through the list of the files in this deposit
        for i in range(len(r.json())):
            # checking if the file exists by comparing the key/filename
            # sending a get request to check information on the file
            if r.json()[i]['filename'] == key:
                # we can retrieve a single deposition file with: 
                # url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files/' + str(file_id)
                # getting the id of the file that we want to download
                file_id =  r.json()[i]['id']
                # getting the download link of the file
                url = r.json()[i]['links']['download']
                r = self('get', url, stream = True)        
                r.raise_for_status()
                # storing the file in the path given in filename
                # this is done by reading the content of the file and writing it in the new file
                # if the files are very large, we can make the chunk size bigger 
                with open(filename, "wb") as f:
                    for chunk in r.iter_content(chunk_size=120): 
                        f.write(chunk)
                # once we finish writing into the file we can close it
                f.close()

        if r.status_code > 204:
            print("error while fetching the file from the remote" + str(r.status_code))
            raise RemoteError('could not send a get query to the API')

#+end_example




** deleting a file.
- First, we have to have the id of a deposit that isn't published to
  be able to delete files. So, we can create a deposit easily with a
  post request or directly via the the sandbox website. We then fetch
  the id of this deposit (ie: 848907) and we go through the list of
  the files that are stored in the deposit and compare their title to
  the key (we can use the url /api/deposit/depositions/:id/files).
  We also have to retrieve the id of the file and append it the url to
  be able to access this file directly. Lastly, we can send a delete
  request to the API to delete it.
     + The Success response that we want: 204
     + Error response: 403 / 404
  
#+begin_src python :results output :exports both
import requests
import json

# the id of the deposit where we want to delete the file
deposit_id = 848907
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}

r = requests.get(url, params=params)

# going through the list of the files in this deposit
file_id = None
for i in range(len(r.json())):
    if r.json()[i]['filename'] == 'notes.pdf':
        file_id = r.json()[i]['id']
        
# Delete an existing deposition file resource. Note, only deposition 
# files for unpublished depositions may be deleted.

# first, we update the url so as to use it to delete the file
url = url + '/' + str(file_id)

# we then make the query to delete the file
r = requests.delete(url, params=params)
print(r.status_code)

#+end_src

#+RESULTS:
: 204

As we can see, the response code is 204 which means that the request
was successfully executed and that the file was deleted. We can also
check this by looking up the url of the deposit on
https://sandbox.zenodo.org/deposit/848907 or by sending a get request
to the API.
We implement this into the remove function so as to delete files from
the deposit.



** Step 7: remove.
"Requests the remote to remove a key's contents."

We first look in the list of the exported files to see if the file
whose name corresponds with the key exists in that deposit. Then, we
fetch the id of the file. Now, we can delete the file using the delete
query (this could only be done to unpublished depositions seeing that
we can not edit pblished ones).
The status code that we want to get in response is 204, so we can
look into that to make sure that the operation was done successfully. 

      #+begin_src python :results output :exports both
    def remove(self, key):
        # remove the key from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        # checking if the key exists in the remote deposit
        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        file_id = None
        for i in range(len(r.json())):
            if r.json()[i]['filename'] == key:
                file_id = r.json()[i]['id']

        # if the key is non existing, we shouldn't raise an exception        
        if file_id is None:
            return
        
        # Delete an existing deposition file resource. Note, only deposition 
        # files for unpublished depositions may be deleted.

        # first, we update the url so as to use it to delete the file
        url = url + '/' + str(file_id)
        # we then make the query to delete the file
        r = self.query('delete', url)

        # raising RemoteError if there is a problem with the removal of the file
        if r.status_code > 204:
            print("error while deleting the file from the remote" + str(r.status_code))
            raise RemoteError('could not send a delete query to the API')
   
      #+end_src

      
** Step 8: transferexportstore.
"Requests the transfer of a file on local disk to the special
remote. Note that it's important that, while a file is being stored,
checkpresentexport() not indicate it's present until all the data has
been transferred. While the transfer is running, the remote can send
any number of progess(size) messages."

We have already implemented a function that does the job of uploading
files into the deposit. So all we have to do now is to use this
function by calling it here and giving as arguments the names of the
remotefile and the localfile. By giving the name of the remotefile as
key, we set the keys as the name of the files which facilitates the
search.

       #+begin_src python :results output :exports both
    def transferexport_store(self, key, local_file, remote_file):
        # store the file located at `local_file` to `remote_file` on the remote
        # raise RemoteError if the file couldn't be stored

        return self.transfer_store(remote_file, local_file)

       #+end_src

       
** Step 9: transferexportretrieve.
"Requests the transfer of a file from the special remote to the local
disk. Note that it's important that, while a file is being stored,
checkpresentexport() not indicate it's present until all the data has
been transferred. While the transfer is running, the remote can send
any number of progess(size) messages."

We have already implemented a function that does the job of fetching
and downloading files from the deposit. So all we have to do now is to use this
function by calling it here and giving as arguments the names of the
remotefile/key and the localfile.
Seeing that the key in this case is the same as the name of the
remotefile we can use either of them.

      #+begin_src python :results output :exports both
    def transferexport_retrieve(self, key, local_file, remote_file):
        # get the file located at `remote_file` from the remote and store it to `local_file`
        # raise RemoteError if the file couldn't be retrieved

        return self.transfer_retrieve(key, local_file)
      #+end_src
  


** Step 10: checkpresentexport.
"Requests the remote to check if the file is present in it."

We use the function checkpresent which we have already implemented to
look in the remote deposit for the file whose key corresponds to the
one given. 

      #+begin_src python :results output :exports both
    def checkpresentexport(self, key, remote_file):
        # return True if the file `remote_file` is present in the remote
        # return False if not
        # raise RemoteError if the presence of the file couldn't be determined, eg. in case of connection error
        
        return self.checkpresent(key)
      #+end_src

      
** Step 11: removeexport.
"Requests the remote to remove content stored by
transferexportstore()."

We use the remove function to look into the list of the uploaded files
and to remove the file whose key corresponds to the one given here.

      #+begin_src python :results output :exports both
    def removeexport(self, key, remote_file):
        # remove the file in `remote_file` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing key isn't considered an error

        return self.remove(key)
      #+end_src


* Monday 07/06.
** Step 12: removeexportdirectory.
 "Requests the remote to remove an exported directory. If the remote
 does not use directories, or removeexport() cleans up directories
 that are empty, this does not need to be implemented."

 We can use this function to remove all files from the deposit seeing
 that we don't have multiple directories in a Zenodo deposit. So to do
 this, we will need to look into the list of the uploaded files, and
 fetch the id of each of the files and then send a delete query to the
 url containing the id of this file (ex: 'url/files/id'). 
 
      #+begin_src python :results output :exports both
    def removeexportdirectory(self, remote_directory):
        # remove the directory `remote_directory` from the remote
        # raise RemoteError if it couldn't be removed
        # note that removing a not existing directory isn't considered an error

        url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(self.deposit_id) + '/files'
        r = self.query('get', url)
        # going through the list of the files in this deposit
        file_id = None
        # manipulating each of the files in this deposit
        for i in range(len(r.json())):
            file_id = r.json()[i]['id']
            if file_id is not None:     
                # Delete an existing deposition file resource. Note, only deposition 
                # files for unpublished depositions may be deleted.
                # first, we update the url so as to use it to delete the file
                url = url + '/' + str(file_id)
                # we then make the query to delete the file
                r = self.query('delete', url)
                # for each of the files
                # raising RemoteError if there is a problem with the removal of the file
                if r.status_code > 204: 
                    print("error while deleting the " + str(i) + " file from the remote" + str(r.status_code))
                    raise RemoteError('could not send a delete query to the API')
      #+end_src


** Test: renaming unpublished files on Zenodo.
*** Renaming using the edit action. 
We can use the action edit to try to edit the name of the file we want
to rename. So, first we need to send a get query to get all the
information about the deposit, before sending the edit query to make
the changes we want to make.
 
#+begin_src python :results output :exports both
    params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
    deposit_id = 851823
    url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'

    # first: the get request
    r = requests.get(url, params = params)
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    print()

    # second: the post request with the edit action to unlock the deposition for editing
    r = requests.post('https://zenodo.org/api/deposit/depositions/' + str(deposit_id) +'/actions/edit', params=params, json={})
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    print()

    r = requests.post('https://zenodo.org/api/deposit/depositions/' + str(deposit_id) +'/actions/discard', params=params, json={})
    print(r.status_code)
    print(json.dumps(r.json(), indent=4))
    print()

"""
    # going through the list of the files in this deposit
    for i in range(len(r.json())):
        # checking if the file exists by comparing the key/filename
        # sending a get request to check information on the file
        if r.json()[i]['files']['filename'] == 'AirPollutionInGrenoble.pdf':
          
    """  
#+end_src

#+RESULTS:


*** Renaming using the Update action.
https://github.com/zenodo/zenodo/issues/1459

#+begin_src python :results output :exports both
import json
import requests

deposit_id = '851823'
params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ str(deposit_id) + '/files'

# first, we get the id of the file we want to name
r = requests.get(url, params = params)
print(r.status_code)

for i in range(len(r.json())):
    if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
        file_id = r.json()[i]['id']
        break;

url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ deposit_id + '/files/' + file_id
headers = {"Content-Type": "application/json"}
data = {"name": "airpollutionstudy.pdf"}

r = requests.put(url, data=json.dumps(data), params = params, headers=headers, json={})
print(r.status_code)
print(json.dumps(r.json(), indent=4))
#+end_src

#+RESULTS:
: 200
: 400
: {
:     "status": 400,
:     "message": "Wrong file on input."
: }


*** Another try with the put request.

#+begin_src python :results output :exports both
def rename_file():
    # trying to rename the file in a different way
    import json
    import requests

    headers = {"Content-Type": "application/json"}
    deposit_id = '851823'
    params = {'access_token': 'K1jsyYfSbH3hVfRWpzXkzTL5RDVy1ppQWet2v3DQu8WFDuWbfn4J9rITsQaG'}
    url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ deposit_id + '/files'

    # first, we get the id of the file we want to name
    r = requests.get(url, params = params)
    print(r.status_code)

    # getting the id of the file
    for i in range(len(r.json())):
        if r.json()[i]['filename'] == 'AirPollutionInGrenoble.pdf':
            file_id = r.json()[i]['id']
            break;

    # first, we get the id of the file we want to name
    url = 'https://sandbox.zenodo.org/api/deposit/depositions/'+ deposit_id + '/files/' + file_id 
    r = requests.get(url, params = params)
    print(r.status_code)
   
    file_desc = r.json()
    if file_desc['filename'] != 'airpollutionstudy.pdf':
        r = requests.put(file_desc['links']['self'], json={'name': 'airpollutionstudy.pdf'}, params=params, headers= headers )
        print(r.status_code)
        print(json.dumps(r.json(), indent=4))


rename_file()
#+end_src

#+RESULTS:
: 200
: 200
: 400
: {
:     "status": 400,
:     "message": "Wrong file on input."
: }


** Step 13: renameexport.
 "Requests the remote rename a file stored on it from filename to
 newfilename. Remotes that support exports but not renaming do not
 need to implement this."
 
      #+begin_src python :results output :exports both

      #+end_src

      
** Step 14: publishing.
*** The things that need to be tackled.
To publish a deposit on Zenodo using the API we can use the publish
action but we need to add some information to the deposit
metadata. The required data depend on what type of publication we need
to do and sometimes extra information needs to be given.
Here is an example of the basic data to add using a put request before
publishing:

#+begin_example
data = {
     'metadata': {
         'title': 'example',
         'upload_type': 'poster',
         'description': 'first upload',
         'creators': [{'name': 'lastname, firstname',
                       'affiliation': 'Zenodo'}]
     }
}

#+end_example

Here are the required attributes to specify:

#+begin_example

- upload_type:
   + publication
   + poster
   + presentation
   + dataset
   + image
   + video
   + software
   + lesson
   + physicalobject
   + other
- publication_date.
- title.
- creators: name (optional: affiliation / orcid / gnd)
- description.
- access_right: open / embargoed / restricted / closed.
- license (if access_right = open | embargoed): "The selected license applies 
to all files in this deposition, but not to the metadata."
- embargo_date (if access_right = embargoed): "When the deposited files will 
be made automatically made publicly available by the system. 
Defaults to current date."
- access_conditions (if access_right = restricted): "Specify the conditions 
under which you grant users access to the files in your upload. User requesting 
access will be asked to justify how they fulfil the conditions. Based on the 
justification, you decide who to grant/deny access."
- publication_type (if upload_type = publication):
   + annotationcollection
   + book
   + section
   + conferencepaper
   + datamanagementplan
   + article
   + patent
   + preprint
   + deliverable
   + milestone
   + proposal
   + report
   + softwaredocumentation
   + taxonomictreatment
   + technicalnote
   + thesis
   + workingpaper
   + other
- image_type (if upload_type = image):
   + figure
   + plot
   + drawing
   + diagram
   + photo
   + other
#+end_example

So, keeping these restrictions in mind, we can take the basic publish
function we have written and add all these information into it.

We can devise the functionalities done by the publish function into
multiple methods that we can call whenever a task is needed to be
completed.

*** Setting the type of the upload.
In this case, we will need to ask the user the type of the update as
well as some extra information in the case of some types that require
them.

#+begin_src python :results output :exports both
    # function to call whenever we can to choose an upload type:
    def setting_uploadtype(self):
        # the possible types of the uploads
        uploadtypes = ['publication', 'poster', 'presentation', 'dataset', 'image', 
                        'video', 'software', 'lesson', 'physicalobject', 'other']

        # in the case: upload_type == 'publication'
        publicationtypes = ['annotationcollection', 'book', 'section', 'conferencepaper', 'datamanagementplan', 
                            'article', 'patent', 'prepint', 'deliverable', 'milestone', 'proposal', 'report', 
                            'softwaredocumentation', 'taxonomictreatment', 'technicalnote', 'thesis', 'workingpaper', 'other']
        # in the case: upload_type == 'image'
        imagetypes = ['figure', 'plot', 'drawing', 'diagram', 'photo', 'other']

        # asking for the initial type of the upload:
        print("What is the type of the upload? Please choose one of these options (ex: 5) \n")
        print("0 - publication \n")
        print("1 - poster \n")
        print("2 - presentation \n")
        print("3 - dataset \n")
        print("4 - image \n")
        print("5 - video \n")        
        print("6 - software \n")
        print("7 - lesson \n")
        print("8 - physical object \n")
        print("9 - other \n")
        n = int(input('Enter the correspoding number: '))
        upload_type = uploadtypes[n]
        
        # taking care of the information concerning the publication type:
        if upload_type == 'publication':
            print('Here are the possible types of publication. Please choose one of them (ex: 5) \n')
            print("0 - annotation collection \n")
            print("1 - book \n")
            print("2 - section \n")
            print("3 - data management plan \n")
            print("4 - article \n")
            print("5 - patent \n")
            print("6 - preprint \n")
            print("7 - deliverable \n")
            print("8 - milestone \n")
            print("9 - proposal \n")
            print("10 - software documentation \n")
            print("11 - taxonomic treatment \n")
            print("12 - technical note \n")
            print("13 - thesis \n")
            print("14 - working paper \n")
            print("15 - other \n")
            n = int(input('Enter the correspoding number: '))
            upload_type = publicationtypes[n]

        elif upload_type == 'image':
            print('Here are the possible types of images. Please choose one of them (ex: 5) \n')
            print("0 - figure \n")
            print("1 - plot \n")
            print("2 - drawing \n")
            print("3 - diagram \n")
            print("4 - photo \n")
            print("5 - other \n")
            n = int(input('Enter the correspoding number: '))
            upload_type = imagetypes[n]
        
        return upload_type 
#+end_src

*** Setting the list of the creators.
Since some publications have multiple authors, we need to use a list
containing information about all of them instead of using a single
dictionary with the required attributes as the keys.
We initialize an empty list and then we ask the user to give
information about each one of the creators. Some of the attributes are
required (familyname and givenname) whereas others can be given
optionally. After receiving the values, we can finally add the
attributes as keys and the values into a dictinnary which will be
stocked in the list. This is done for each creator.

#+begin_src python :results output :exports both
    def setting_creators(self):
        creators = []
        c = {}
        nbcreators = int(input("Enter the number of the creators of this upload. \n"))
        for i in range(nbcreators):
            print("For the " + str(i) + " creator: \n")
            family_name = input('Enter the Family name (Required): \n')
            given_name = input('Enter the Given name (Required): \n')
            affiliation = input('Enter the affiliation of the creator or press enter to pass (Optional): \n')
            orcid = input('Enter the orcid of the creator or press enter to pass (Optional): \n')
            gnd = input('Enter the gnd of the creator or press enter to pass (Optional): \n')
            c['name'] = "%s, %s" % (family_name, given_name)
            if affiliation != '':
                c['affiliation'] = affiliation
            if orcid != '':
                c['orcid'] = orcid
            if gnd != '':
                c['gnd'] = gnd
            creators.append(c)

        return creators
#+end_src

*** Setting the access rights.
This function to call to set the access right to the publication. The
user chooses which type of access to give and takes care of any
additional information that depends on the chosen access.

For instance, when we want to create a new version of a deposit
without having to make it publicly available (seeing that it needs to
be published), we can publish it while choosing the accessright as
closed. This will allow us to manipulate the new version however we
please while still keeping the content closed.

#+begin_src python :results output :exports both
    def setting_accessright (self):
        
        # initializing the list of options
        accessrights = ['open', 'embargoed', 'restricted', 'closed']
        licenses = ['Creative Commons Attribution 4.0 International', 'Creative Commons Attribution 1.0 Generic', 
                    'Creative Commons Attribution 2.0 Generic', 'Creative Commons Attribution 3.0 Unported']
        
        # choosing the access right 
        print("What is the access right of the upload? Please choose one of these options (ex: 2) \n")
        print("0 - open \n")
        print("1 - embargoed \n")
        print("2 - restricted \n")
        print("3 - closed \n")        
        n = int(input('Enter the correspoding number: '))
        access_right = accessrights[n]        

        # taking care of the extra information concerning all the possible access rights
        
        if access_right == 'embargoed':
            # need to specify embargo_date
            print('Specify the Embargo date. The format is: YYYY-MM-DD. \n')
            embargo_date = input()

        if access_right == 'embargoed' or access_right == 'open':
            # need to specify the license
            print('Specify the license. Choose one of these options: \n')
            print("0 - Creative Commons Attribution 4.0 International \n")
            print("1 - Creative Commons Attribution 1.0 Generic \n")
            print("2 - Creative Commons Attribution 2.0 Generic \n")
            print("3 - Creative Commons Attribution 3.0 Unported \n")               
            n = int(input('Enter the correspoding number: ')) 
            license = licenses[n]

        if access_right == 'restricted':
            # need to specify access_conditions
            print('Specify the conditions under which you grant users access to the files in your upload. \n')
            access_conditions = input()

#+end_src

*** Getting the licenses.
if we need to get all the possible licenses, we can send a get query
to api (url: /api/licenses/') and we will get in response a list
containing all the licenses with extra information.

#+begin_src python :results output :exports both
def list():
    import requests
    import json
    r = requests.get('https://sandbox.zenodo.org/api/licenses/')
    print(json.dumps(r.json(), indent=4))  

list()
#+end_src





* Tuesday 08/06.
- checksum: look into storing it when we  upload a file into zenodo so
  that we can compare it to the checksum and know the versions when we
  want to check later.

- if we want to keep the hierarchy of the files and the folders when
  we upload them, there is a problem seeing that zenodo doesn't
  support folders. If we add an archive when we upload to keep the
  state of the repository when we upload it (we can publish the
  content of the git repository as a zip).

  have a file (script) that keeps the right place for each of the
  files. We can store the correct hierarchy of the files in this file
  that is written in a simple format. 

-  git annex init zenodo: when we init a new version of a deposit for
  example we have to find a way to keep a link between the files that
  we have already published and the versions of these files that are
  in the new deposit. We can for instance look in the list of the
  annexed files and compare the ids of these files that have already
  been annexed in an old deposit and make a new link with the copies
  of these files that are in the new version of the deposit. (ex: git
  annex init zenodo --from id)

  the flow of the commands:
  git annex init zenodo --from id
  git annex add
  git annex sync
  git tree-to-zenodo --bucket-id     // doesn't really go through git
  annex, we can do this before publishing the deposit so that we can
  add the file that keeps the state of the repository 
  git annex zenodo-to-web

  We can remove the command to take care of uploading the tree to
  zenodo and add an option instead to the zenodo-to-web command
  (--with-tree --with-link) where we add a file / zip containing the
  git information about this file and the sym link referencing each
  one of the files.

  If there is a problem for instance when we upload a file that isn't
  referenced we can for example (git annex remove-unreferenced --backend-zenodo) which removes
  the files from the deposit that aren't referenced and that don't
  have a symbolic link for us to reach them later on. 

  We can have this as the blueprint of the list of commands to make
  when we want to manipulate the datasets/files and upload them into
  zenodo while still keeping the heirarchy of the files and the
  referencing the git symbolic links that they have been annexed with
  so as to be able to reuse them if we for instance want to init a new
  version of a deposit:
  
  git annex init zenodo --from id
  git annex add
  git annex sync
  git annex remove-unreferenced --backend-zenodo
  git annex zenodo-to-web

  Look into a command that adds referenced / remove unreferenced
  automatically for all the backend remotes in git annex. ! 

- for the publishing step we can create a file where we set up all the
  necessary information to give to the api to be able to
  publish. Instead of asking for the user to insert all the details
  while passing the command, we can keep a json file containing all
  this information and then just read from it when we want to sent the
  put query to the API before we publish.

- For datalad the issue had been discussed as to how to add this
  functionality to datalad when working with some remotes that don't
  really support directories and file hierarchy. For instance, the use
  of git/refs or git-repo.zip could be interesting to upload with the
  flat hierarchy.  
    + link: https://github.com/datalad/datalad/issues/5221
  
- RIA:
  https://github.com/datalad/datalad/blob/master/datalad/distributed/create_sibling_ria.py


- to do:
+ play a little with remote directory to see how it works / the
  representation of the data and the functioning of the commands.
+ keep looking into Datalad issues to see if Zenodo was mentionned by
  someone and if yes see why it's not been looked into as a possible
  special remote.
+ look at how the datalad export-to-figshare is implemented. 
  
- We can have a method (ex: getrefs) that gets the references that are
  kept in a dedicated file in the remote.
 
- For bigger datasets why not also upload the files that are at the
  top of the hierarchy first and then upload the subdirectories as
  archives later on.

- "An ideal "data publishing/hosting" should allow both push/pull
  (download/publish) for any of the files while retaining original
  directory structure. Then interactions could be established back at
  the level of git-annex itself, like it does e.g. for S3 now. And if
  download of a full or subset is needed - would generate
  (reproducibly, so sorting the files and injecting consistent archive
  header) a zipball on the fly."

- 

